ØªØµÙ…ÙŠÙ… Ù…Ù‚Ø³Ù… Ø§Ù„Ø´Ø¹Ø§Ø¹ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ÙŠ (Directional Coupler) Ù„Ù„Ø¯ÙˆØ§Ø¦Ø± Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ©
: /03_FABRICATION/component_library/directional_coupler.py

```python
"""
Ù…Ù‚Ø³Ù… Ø´Ø¹Ø§Ø¹ Ø§ØªØ¬Ø§Ù‡ÙŠ Ù…ØªÙ‚Ø¯Ù… Ù„Ù„Ø¯ÙˆØ§Ø¦Ø± Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ© Ø§Ù„Ø¶ÙˆØ¦ÙŠØ©.
ÙŠØ¯Ø¹Ù…: Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù‚ØªØ±Ø§Ù† Ù…Ø®ØªÙ„ÙØ©ØŒ ØªØµÙ…ÙŠÙ…Ø§Øª Ù…ØªÙˆØ§Ø²ÙŠØ© ÙˆÙ…Ù†Ø­Ù†ÙŠØ©ØŒ ÙˆØ£Ø¯Ø§Ø¡ ÙƒÙ…ÙŠ Ù…Ø­Ø³Ù†.
"""
import numpy as np
import gdspy
import yaml
from typing import Tuple, List, Dict, Optional
import json
from dataclasses import dataclass

@dataclass
class CouplerDesignParameters:
    """Ù…Ø¹Ù„Ù…Ø§Øª ØªØµÙ…ÙŠÙ… Ù…Ù‚Ø³Ù… Ø§Ù„Ø´Ø¹Ø§Ø¹."""
    coupling_ratio: float  # |t|Â² (0 Ø¥Ù„Ù‰ 1)
    length: float          # Ø·ÙˆÙ„ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù† (Î¼m)
    gap: float             # Ø§Ù„ÙØ¬ÙˆØ© Ø¨ÙŠÙ† Ø§Ù„Ø£Ø¯Ù„Ø© (Î¼m)
    width: float           # Ø¹Ø±Ø¶ Ø§Ù„Ø¯Ù„ÙŠÙ„ (Î¼m)
    wavelength: float      # Ø§Ù„Ø·ÙˆÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù (nm)
    material: str          # Ø§Ù„Ù…Ø§Ø¯Ø© ('Si3N4' Ø£Ùˆ 'AlGaAs')

class QuantumDirectionalCoupler:
    """
    Ù…Ù‚Ø³Ù… Ø´Ø¹Ø§Ø¹ ÙƒÙ…ÙŠ Ù…ØªÙ‚Ø¯Ù… Ù…Ø¹ Ù…Ø­Ø§ÙƒØ§Ø© Ø¶ÙˆØ¦ÙŠØ© Ù…Ø¯Ù…Ø¬Ø©.
    
    Ø§Ù„Ù…ÙŠØ²Ø§Øª:
    1. ØªØµÙ…ÙŠÙ…Ø§Øª Ù…ØªÙˆØ§Ø²ÙŠØ© ÙˆÙ…Ù†Ø­Ù†ÙŠØ©
    2. ØªÙ‚ÙˆÙŠÙ… ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„Ù…Ø³Ø§Ø± (path correction)
    3. ØªØ¯Ø±Ø¬Ø§Øª (tapers) Ù„Ø­ÙØ¸ Ø§Ù„Ø§Ø³ØªÙ‚Ø·Ø§Ø¨
    4. Ù…Ø±Ø§Ù‚Ø¨Ø© Ø®Ø³Ø§Ø¦Ø± Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù†
    """
    
    def __init__(self, layer: int = 1, pdk_path: str = "../PDK/design_rules.yaml"):
        self.layer = layer
        self.coupler_layer = layer
        self.label_layer = layer + 100  # Ø·Ø¨Ù‚Ø© Ø§Ù„Ù†ØµÙˆØµ
        
        # ØªØ­Ù…ÙŠÙ„ Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØµÙ…ÙŠÙ…
        with open(pdk_path, 'r') as f:
            self.drc = yaml.safe_load(f)
        
        # Ù‚ÙŠÙˆØ¯ Ù…Ù† PDK
        self.min_gap = self.drc['layer_specific'][0]['rules']['min_spacing']
        self.min_width = self.drc['layer_specific'][0]['rules']['min_width']
        self.max_width = self.drc['layer_specific'][0]['rules'].get('max_width', 2.0)
        
        # Ø«ÙˆØ§Ø¨Øª ØªØµÙ…ÙŠÙ…ÙŠØ© Ù…Ø«Ù„Ù‰
        self.taper_length = 10.0  # Ø·ÙˆÙ„ Ø§Ù„ØªØ¯Ø±Ø¬
        self.bend_radius = 5.0    # Ù†ØµÙ Ù‚Ø·Ø± Ø§Ù„Ø§Ù†Ø­Ù†Ø§Ø¡
    
    def calculate_coupling_parameters(self, params: CouplerDesignParameters) -> Dict:
        """
        Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¹Ù„Ù…Ø§Øª Ø§Ù„Ø¶ÙˆØ¦ÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù† Ø§Ù„Ù…Ø·Ù„ÙˆØ¨.
        
        Ø§Ù„ØµÙŠØº Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ÙŠØ©:
        Îº = sinÂ²(Ï€Î”nL/Î»)  Ø­ÙŠØ« Î”n ØªØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø§Ù„ÙØ¬ÙˆØ© ÙˆØ§Ù„Ø¹Ø±Ø¶
        """
        # Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù† (Îº)
        kappa = params.coupling_ratio  # |t|Â² = 1 - Îº
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø·ÙˆÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ (ØªÙ‚Ø±ÙŠØ¨ÙŠ)
        # Ù„Ù€ Siâ‚ƒNâ‚„: Î”n â‰ˆ 0.01 Ã— exp(-gap/0.2)
        delta_n = 0.01 * np.exp(-params.gap / 0.2)
        
        # Ø§Ù„Ø·ÙˆÙ„ Ø§Ù„Ù…Ø«Ø§Ù„ÙŠ Ù„ØªØ­Ù‚ÙŠÙ‚ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù† Ø§Ù„Ù…Ø·Ù„ÙˆØ¨
        # Ù…Ù† Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù†: Îº = sinÂ²(Ï€Î”nL/Î»)
        if delta_n > 0:
            optimal_length = (np.arcsin(np.sqrt(kappa)) * params.wavelength) / (np.pi * delta_n)
        else:
            optimal_length = params.length
        
        # Ø­Ø³Ø§Ø¨ ÙÙ‚Ø¯ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù† (ØªÙ‚Ø±ÙŠØ¨ÙŠ)
        loss_dB = 0.02 * params.length  # 0.02 dB/Î¼m
        
        return {
            'kappa': kappa,
            'delta_n': delta_n,
            'optimal_length_um': optimal_length,
            'coupling_loss_dB': loss_dB,
            'theoretical_fidelity': 1 - 0.001 * params.length  # Ø¥Ø®Ù„Ø§Øµ Ù†Ø¸Ø±ÙŠ
        }
    
    def create_parallel_coupler(self, 
                               center: Tuple[float, float],
                               params: CouplerDesignParameters,
                               orientation: str = 'horizontal') -> gdspy.Cell:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø³Ù… Ø´Ø¹Ø§Ø¹ Ù…ØªÙˆØ§Ø²ÙŠ (ØªØµÙ…ÙŠÙ… ØªÙ‚Ù„ÙŠØ¯ÙŠ).
        
        Args:
            center: Ø§Ù„Ù…Ø±ÙƒØ² Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ (x, y)
            params: Ù…Ø¹Ù„Ù…Ø§Øª Ø§Ù„ØªØµÙ…ÙŠÙ…
            orientation: 'horizontal' Ø£Ùˆ 'vertical'
        """
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØµÙ…ÙŠÙ…
        self._validate_design(params)
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø®Ù„ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©
        cell_name = f"DC_parallel_C{params.coupling_ratio:.2f}_L{params.length:.1f}"
        cell = gdspy.Cell(cell_name)
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø²Ø§Ø­Ø©
        y_offset = params.gap / 2 + params.width / 2
        
        if orientation == 'horizontal':
            # Ø§Ù„Ø£Ø¯Ù„Ø© Ø§Ù„Ø£ÙÙ‚ÙŠØ© Ø§Ù„Ù…ØªÙˆØ§Ø²ÙŠØ©
            # Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø³ÙÙ„ÙŠ
            wg1_points = [
                (center[0] - params.length/2, center[1] - y_offset),
                (center[0] + params.length/2, center[1] - y_offset)
            ]
            
            # Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø¹Ù„ÙˆÙŠ
            wg2_points = [
                (center[0] - params.length/2, center[1] + y_offset),
                (center[0] + params.length/2, center[1] + y_offset)
            ]
        else:
            # Ø§Ù„Ø£Ø¯Ù„Ø© Ø§Ù„Ø±Ø£Ø³ÙŠØ© Ø§Ù„Ù…ØªÙˆØ§Ø²ÙŠØ©
            x_offset = params.gap / 2 + params.width / 2
            
            # Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø£ÙŠØ³Ø±
            wg1_points = [
                (center[0] - x_offset, center[1] - params.length/2),
                (center[0] - x_offset, center[1] + params.length/2)
            ]
            
            # Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø£ÙŠÙ…Ù†
            wg2_points = [
                (center[0] + x_offset, center[1] - params.length/2),
                (center[0] + x_offset, center[1] + params.length/2)
            ]
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø¯Ù„Ø©
        from waveguide import QuantumWaveguide
        wg = QuantumWaveguide(width=params.width, layer=self.layer)
        
        # Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø£ÙˆÙ„
        wg1 = wg.create_straight(wg1_points[0], wg1_points[1])
        # Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø«Ø§Ù†ÙŠ
        wg2 = wg.create_straight(wg2_points[0], wg2_points[1])
        
        # Ø¥Ø¶Ø§ÙØ© ØªØ¯Ø±Ø¬Ø§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„/Ø§Ù„Ø®Ø±ÙˆØ¬
        taper_cell = self._create_input_output_tapers(center, params, orientation)
        
        # Ø¬Ù…Ø¹ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª
        cell.add(wg1)
        cell.add(wg2)
        cell.add(taper_cell)
        
        # Ø¥Ø¶Ø§ÙØ© ØªØ³Ù…ÙŠØ§Øª ØªØ´Ø®ÙŠØµÙŠØ©
        self._add_diagnostic_labels(cell, center, params, "parallel")
        
        return cell
    
    def create_curved_coupler(self,
                             start_point: Tuple[float, float],
                             params: CouplerDesignParameters,
                             bend_direction: str = 'up') -> gdspy.Cell:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø³Ù… Ø´Ø¹Ø§Ø¹ Ù…Ù†Ø­Ù†ÙŠ (Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ ÙˆØ²ÙŠØ§Ø¯Ø© Ø§Ù„Ø·ÙˆÙ„ Ø§Ù„ÙØ¹Ø§Ù„).
        
        Args:
            start_point: Ù†Ù‚Ø·Ø© Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø³ÙÙ„ÙŠ
            params: Ù…Ø¹Ù„Ù…Ø§Øª Ø§Ù„ØªØµÙ…ÙŠÙ…
            bend_direction: 'up' Ø£Ùˆ 'down' Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø§Ù†Ø­Ù†Ø§Ø¡
        """
        self._validate_design(params)
        
        cell_name = f"DC_curved_C{params.coupling_ratio:.2f}_L{params.length:.1f}"
        cell = gdspy.Cell(cell_name)
        
        # Ø¥Ø´Ø§Ø±Ø© Ø§Ù„Ø§ØªØ¬Ø§Ù‡
        dir_sign = 1 if bend_direction == 'up' else -1
        
        # Ø­Ø³Ø§Ø¨ Ù†Ù‚Ø§Ø· Ø§Ù„ØªØ­ÙƒÙ… Ù„Ù„Ù…Ù†Ø­Ù†Ù‰
        # Ù†Ø³ØªØ®Ø¯Ù… Ù…Ù†Ø­Ù†ÙŠØ§Øª Bezier Ù„Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø§Ù„Ø³Ù„Ø³
        from waveguide import QuantumWaveguide
        wg = QuantumWaveguide(width=params.width, layer=self.layer)
        
        # 1. Ù…Ù†Ø­Ù†Ù‰ Ø§Ù„Ø¯Ø®ÙˆÙ„ (S-bend)
        control_points_in = [
            start_point,
            (start_point[0] + 10, start_point[1]),
            (start_point[0] + 20, start_point[1] + dir_sign * 5),
            (start_point[0] + 30, start_point[1] + dir_sign * 5)
        ]
        
        # 2. Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù† Ø§Ù„Ù…Ø³ØªÙ‚ÙŠÙ…Ø©
        coupling_start = control_points_in[-1]
        coupling_end = (coupling_start[0] + params.length, coupling_start[1])
        
        # 3. Ù…Ù†Ø­Ù†Ù‰ Ø§Ù„Ø®Ø±ÙˆØ¬ (S-bend Ù…Ø¹ÙƒÙˆØ³)
        control_points_out = [
            coupling_end,
            (coupling_end[0] + 10, coupling_end[1]),
            (coupling_end[0] + 20, coupling_end[1] - dir_sign * 5),
            (coupling_end[0] + 30, coupling_end[1] - dir_sign * 5)
        ]
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø¯Ù„Ø©
        # Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø³ÙÙ„ÙŠ/Ø§Ù„Ø¹Ù„ÙˆÙŠ (Ø­Ø³Ø¨ Ø§Ù„Ø§ØªØ¬Ø§Ù‡)
        lower_wg_points = [
            start_point,
            coupling_start,
            coupling_end,
            control_points_out[-1]
        ]
        
        # Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…Ù‚Ø§Ø¨Ù„ (Ù…Ø²Ø§Ø­)
        upper_offset = dir_sign * (params.gap + params.width)
        upper_wg_points = [
            (start_point[0], start_point[1] + upper_offset),
            (coupling_start[0], coupling_start[1] + upper_offset),
            (coupling_end[0], coupling_end[1] + upper_offset),
            (control_points_out[-1][0], control_points_out[-1][1] + upper_offset)
        ]
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø¯Ù„Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ù†Ø­Ù†ÙŠØ§Øª Bezier
        lower_path = self._create_bezier_waveguide(lower_wg_points, params.width)
        upper_path = self._create_bezier_waveguide(upper_wg_points, params.width)
        
        # Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØªØ¯Ø±Ø¬Ø§Øª
        taper_in = self._create_taper(start_point, params.width, 1.0, orientation='horizontal')
        taper_out = self._create_taper(control_points_out[-1], params.width, 1.0, orientation='horizontal')
        
        # ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª
        cell.add(lower_path)
        cell.add(upper_path)
        cell.add(taper_in)
        cell.add(taper_out)
        
        # Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù† Ø§Ù„Ù…ÙˆØ³Ø¹Ø© (Ù„Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©)
        coupling_region = self._create_coupling_region_visualization(
            coupling_start, coupling_end, params
        )
        cell.add(coupling_region)
        
        self._add_diagnostic_labels(cell, 
                                  ((start_point[0] + control_points_out[-1][0])/2, 
                                   (start_point[1] + upper_wg_points[0][1])/2),
                                  params, "curved")
        return cell
    
    def create_multi_coupler_array(self,
                                  start_point: Tuple[float, float],
                                  coupling_ratios: List[float],
                                  spacing: float = 50.0) -> gdspy.Cell:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ù…ØµÙÙˆÙØ© Ù…Ù† Ù…Ù‚Ø³Ù…Ø§Øª Ø§Ù„Ø£Ø´Ø¹Ø© Ø¨Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù‚ØªØ±Ø§Ù† Ù…Ø®ØªÙ„ÙØ©.
        Ù…Ø«Ø§Ù„ÙŠ Ù„Ù‡ÙŠØ§ÙƒÙ„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± ÙˆØ§Ù„ØªÙˆØµÙŠÙ.
        """
        cell = gdspy.Cell("MultiCoupler_Array")
        
        # Ù…Ø¹Ù„Ù…Ø§Øª Ø£Ø³Ø§Ø³ÙŠØ©
        base_params = CouplerDesignParameters(
            coupling_ratio=0.5,
            length=20.0,
            gap=0.15,
            width=0.5,
            wavelength=1550.0,
            material='Si3N4'
        )
        
        current_x = start_point[0]
        current_y = start_point[1]
        
        for i, ratio in enumerate(coupling_ratios):
            # ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù†
            params = CouplerDesignParameters(
                coupling_ratio=ratio,
                length=base_params.length,
                gap=base_params.gap * (1 + 0.1 * i),  # ØªØºÙŠÙŠØ± Ø·ÙÙŠÙ ÙÙŠ Ø§Ù„ÙØ¬ÙˆØ©
                width=base_params.width,
                wavelength=base_params.wavelength,
                material=base_params.material
            )
            
            # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ù‚Ø³Ù…
            coupler = self.create_parallel_coupler(
                center=(current_x, current_y),
                params=params,
                orientation='horizontal'
            )
            
            cell.add(coupler)
            
            # Ø¥Ø¶Ø§ÙØ© ØªØ³Ù…ÙŠØ© ÙˆØ§Ø¶Ø­Ø©
            label = gdspy.Label(
                f"Îº={ratio:.2f}",
                (current_x, current_y - 10),
                self.label_layer
            )
            cell.add(label)
            
            # Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„Ù„Ø¹Ù†ØµØ± Ø§Ù„ØªØ§Ù„ÙŠ
            current_x += spacing
        
        return cell
    
    def create_balanced_beam_splitter(self,
                                     center: Tuple[float, float],
                                     design_type: str = '50-50') -> gdspy.Cell:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø³Ù… Ø´Ø¹Ø§Ø¹ Ù…ØªÙˆØ§Ø²Ù† 50:50 (Ø¨ÙˆØ§Ø³Ø·Ø© Hadamard ÙÙŠ Ø§Ù„Ø­ÙˆØ³Ø¨Ø© Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ©).
        
        Types:
        - '50-50': Ù…Ù‚Ø³Ù… Ø´Ø¹Ø§Ø¹ Ù…Ø«Ø§Ù„ÙŠ
        - 'asymmetric': Ù„Ù‚ÙŠØ§Ø³Ø§Øª Ø§Ù„ØªØ¯Ø§Ø®Ù„
        - 'tunable': Ù…Ø¹ Ù…Ø³Ø®Ù† Ù„Ù„ØªØ­ÙƒÙ…
        """
        if design_type == '50-50':
            params = CouplerDesignParameters(
                coupling_ratio=0.5,  # 50% Ø§Ù‚ØªØ±Ø§Ù†
                length=20.0,
                gap=0.15,
                width=0.5,
                wavelength=1550.0,
                material='Si3N4'
            )
        elif design_type == 'asymmetric':
            params = CouplerDesignParameters(
                coupling_ratio=0.1,  # 10% Ø§Ù‚ØªØ±Ø§Ù†
                length=10.0,
                gap=0.25,
                width=0.5,
                wavelength=1550.0,
                material='Si3N4'
            )
        
        cell = self.create_parallel_coupler(center, params, 'horizontal')
        
        # Ø¥Ø¶Ø§ÙØ© ØªØ³Ù…ÙŠØ© Ø®Ø§ØµØ©
        label = gdspy.Label(
            f"BS_{design_type}",
            (center[0], center[1] + 15),
            self.label_layer
        )
        cell.add(label)
        
        # Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‚Ø§Ø¨Ù„ Ù„Ù„Ø¶Ø¨Ø·ØŒ Ø£Ø¶Ù Ù…Ø³Ø®Ù†
        if design_type == 'tunable':
            heater = self._add_thermal_tuner(center, params)
            cell.add(heater)
        
        return cell
    
    def _create_input_output_tapers(self, 
                                   center: Tuple[float, float],
                                   params: CouplerDesignParameters,
                                   orientation: str) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ ØªØ¯Ø±Ø¬Ø§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„ ÙˆØ§Ù„Ø®Ø±ÙˆØ¬ Ù„Ø­ÙØ¸ Ø§Ù„Ø§Ø³ØªÙ‚Ø·Ø§Ø¨."""
        taper_cell = gdspy.Cell("DC_Tapers")
        
        # Ø¹Ø±Ø¶ Ø§Ù„Ø¯Ø®Ù„/Ø§Ù„Ø®Ø±Ø¬ Ø§Ù„Ù‚ÙŠØ§Ø³ÙŠ
        port_width = 1.0  # Î¼m
        
        if orientation == 'horizontal':
            # ØªØ¯Ø±Ø¬Ø§Øª Ø£ÙÙ‚ÙŠØ©
            for y_offset in [-(params.gap/2 + params.width/2), 
                           (params.gap/2 + params.width/2)]:
                
                # Ø§Ù„Ø¬Ø§Ù†Ø¨ Ø§Ù„Ø£ÙŠØ³Ø±
                left_points = [
                    (center[0] - params.length/2 - self.taper_length, center[1] + y_offset),
                    (center[0] - params.length/2, center[1] + y_offset)
                ]
                
                # Ø§Ù„Ø¬Ø§Ù†Ø¨ Ø§Ù„Ø£ÙŠÙ…Ù†
                right_points = [
                    (center[0] + params.length/2, center[1] + y_offset),
                    (center[0] + params.length/2 + self.taper_length, center[1] + y_offset)
                ]
                
                # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªØ¯Ø±Ø¬Ø§Øª
                from waveguide import QuantumWaveguide
                wg = QuantumWaveguide(width=port_width, layer=self.layer)
                
                # ØªØ¯Ø±Ø¬ Ø§Ù„Ø¯Ø®ÙˆÙ„ (Ø¶ÙŠÙ‚ Ø¥Ù„Ù‰ Ø¹Ø±ÙŠØ¶)
                taper_in = wg.create_straight(
                    left_points[0], left_points[1],
                    taper_start=port_width, taper_end=params.width
                )
                
                # ØªØ¯Ø±Ø¬ Ø§Ù„Ø®Ø±ÙˆØ¬ (Ø¹Ø±ÙŠØ¶ Ø¥Ù„Ù‰ Ø¶ÙŠÙ‚)
                taper_out = wg.create_straight(
                    right_points[0], right_points[1],
                    taper_start=params.width, taper_end=port_width
                )
                
                taper_cell.add(taper_in)
                taper_cell.add(taper_out)
        
        return taper_cell
    
    def _create_bezier_waveguide(self, 
                               control_points: List[Tuple[float, float]],
                               width: float) -> gdspy.PolygonSet:
        """Ø¥Ù†Ø´Ø§Ø¡ Ø¯Ù„ÙŠÙ„ Ù…ÙˆØ¬ÙŠ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ù†Ø­Ù†ÙŠØ§Øª Bezier Ù„Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø§Ù„Ø³Ù„Ø³."""
        # ØªÙ‚Ø±ÙŠØ¨ÙŠ: Ù†Ø³ØªØ®Ø¯Ù… Ø®Ø·ÙˆØ·Ø§Ù‹ Ù…Ø³ØªÙ‚ÙŠÙ…Ø© Ø¨ÙŠÙ† Ù†Ù‚Ø§Ø· Ø§Ù„ØªØ­ÙƒÙ…
        # ÙÙŠ Ø§Ù„ØªÙ†ÙÙŠØ° Ø§Ù„ÙƒØ§Ù…Ù„: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ù†Ø­Ù†ÙŠØ§Øª Bezier Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©
        from waveguide import QuantumWaveguide
        wg = QuantumWaveguide(width=width, layer=self.layer)
        
        # ÙˆØµÙ„ Ø§Ù„Ù†Ù‚Ø§Ø· Ø¨Ø®Ø·ÙˆØ· Ù…Ø³ØªÙ‚ÙŠÙ…Ø©
        polygon_points = []
        for i in range(len(control_points) - 1):
            segment = wg.create_straight(control_points[i], control_points[i+1])
            # ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù†Ù‚Ø§Ø· (Ù‡Ø°Ø§ ØªØ¨Ø³ÙŠØ·)
            polygon_points.extend(control_points[i])
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¶Ù„Ø¹ (ØªØ¨Ø³ÙŠØ·)
        return gdspy.Polygon(polygon_points, layer=self.layer)
    
    def _create_coupling_region_visualization(self,
                                            start: Tuple[float, float],
                                            end: Tuple[float, float],
                                            params: CouplerDesignParameters) -> gdspy.PolygonSet:
        """Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù†Ø·Ù‚Ø© Ù…Ø±Ø¦ÙŠØ© Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù† Ù„Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©."""
        # Ù…Ù†Ø·Ù‚Ø© Ù…Ø³ØªØ·ÙŠÙ„Ø© Ø­ÙˆÙ„ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù†
        height = params.gap + 2 * params.width + 1.0  # Ù…Ø¹ Ù‡Ø§Ù…Ø´
        
        points = [
            (start[0], start[1] - height/2),
            (end[0], end[1] - height/2),
            (end[0], end[1] + height/2),
            (start[0], start[1] + height/2)
        ]
        
        return gdspy.Polygon(points, layer=self.layer+1)  # Ø·Ø¨Ù‚Ø© Ù…Ø³Ø§Ø¹Ø¯Ø©
    
    def _create_taper(self,
                     position: Tuple[float, float],
                     start_width: float,
                     end_width: float,
                     orientation: str = 'horizontal') -> gdspy.PolygonSet:
        """Ø¥Ù†Ø´Ø§Ø¡ ØªØ¯Ø±Ø¬ (taper) Ø¨Ø³ÙŠØ·."""
        length = self.taper_length
        
        if orientation == 'horizontal':
            points = [
                (position[0], position[1] - start_width/2),
                (position[0] + length, position[1] - end_width/2),
                (position[0] + length, position[1] + end_width/2),
                (position[0], position[1] + start_width/2)
            ]
        else:  # Ø±Ø£Ø³ÙŠ
            points = [
                (position[0] - start_width/2, position[1]),
                (position[0] - end_width/2, position[1] + length),
                (position[0] + end_width/2, position[1] + length),
                (position[0] + start_width/2, position[1])
            ]
        
        return gdspy.Polygon(points, layer=self.layer)
    
    def _add_thermal_tuner(self,
                          center: Tuple[float, float],
                          params: CouplerDesignParameters) -> gdspy.PolygonSet:
        """Ø¥Ø¶Ø§ÙØ© Ù…Ø³Ø®Ù† Ø­Ø±Ø§Ø±ÙŠ Ù„Ù„ØªØ­ÙƒÙ… Ø¨Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù†."""
        # Ø§Ù„Ù…Ø³Ø®Ù† ÙÙˆÙ‚ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù†
        heater_length = params.length
        heater_width = 0.3  # Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø³Ø®Ù†
        heater_gap = 0.5    # Ø§Ù„ÙØ¬ÙˆØ© Ø¹Ù† Ø§Ù„Ø¯Ù„ÙŠÙ„
        
        points = [
            (center[0] - heater_length/2, center[1] + params.width/2 + heater_gap),
            (center[0] + heater_length/2, center[1] + params.width/2 + heater_gap),
            (center[0] + heater_length/2, center[1] + params.width/2 + heater_gap + heater_width),
            (center[0] - heater_length/2, center[1] + params.width/2 + heater_gap + heater_width)
        ]
        
        # Ù†Ù‚Ø§Ø· Ø§Ù„ØªÙˆØµÙŠÙ„ Ø§Ù„ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠ
        pad_size = 2.0
        left_pad = gdspy.Rectangle(
            (center[0] - heater_length/2 - pad_size, center[1] + params.width/2 + heater_gap),
            (center[0] - heater_length/2, center[1] + params.width/2 + heater_gap + heater_width + pad_size),
            layer=10  # Ø·Ø¨Ù‚Ø© Ø§Ù„Ù…Ø¹Ø¯Ù†
        )
        
        right_pad = gdspy.Rectangle(
            (center[0] + heater_length/2, center[1] + params.width/2 + heater_gap),
            (center[0] + heater_length/2 + pad_size, center[1] + params.width/2 + heater_gap + heater_width + pad_size),
            layer=10
        )
        
        # Ø§Ù„Ø¬Ù…Ø¹
heater = gdspy.Polygon(points, layer=10)
        return gdspy.CellReference(heater) + left_pad + right_pad
    
    def _add_diagnostic_labels(self,
                              cell: gdspy.Cell,
                              position: Tuple[float, float],
                              params: CouplerDesignParameters,
                              design_type: str):
        """Ø¥Ø¶Ø§ÙØ© ØªØ³Ù…ÙŠØ§Øª ØªØ´Ø®ÙŠØµÙŠØ© ÙˆØ¹Ù„Ø§Ù…Ø§Øª Ù‚ÙŠØ§Ø³."""
        # Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªØµÙ…ÙŠÙ…
        info_text = f"DC_{design_type}_Îº{params.coupling_ratio:.2f}_L{params.length:.1f}_G{params.gap:.2f}"
        
        label = gdspy.Label(
            info_text,
            (position[0], position[1] - 5),
            self.label_layer
        )
        cell.add(label)
        
        # Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ù‚ÙŠØ§Ø³
        measure_markers = self._create_measurement_markers(position, params.length)
        cell.add(measure_markers)
    
    def _create_measurement_markers(self,
                                   center: Tuple[float, float],
                                   length: float) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ù„Ø§Ù…Ø§Øª Ù‚ÙŠØ§Ø³ Ù„Ù„Ù…Ø­Ø§Ø°Ø§Ø© ÙˆØ§Ù„ØªÙˆØµÙŠÙ."""
        marker_cell = gdspy.Cell("Measurement_Markers")
        
        # Ø¹Ù„Ø§Ù…Ø§Øª Ø¹Ù„Ù‰ Ø¬Ø§Ù†Ø¨ÙŠ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù†
        marker_size = 0.5
        
        for x_offset in [-length/2 - 5, length/2 + 5]:
            for y_offset in [-3, 0, 3]:
                marker = gdspy.Rectangle(
                    (center[0] + x_offset - marker_size/2, center[1] + y_offset - marker_size/2),
                    (center[0] + x_offset + marker_size/2, center[1] + y_offset + marker_size/2),
                    layer=self.label_layer
                )
                marker_cell.add(marker)
        
        return marker_cell
    
    def _validate_design(self, params: CouplerDesignParameters):
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªÙˆØ§ÙÙ‚ Ø§Ù„ØªØµÙ…ÙŠÙ… Ù…Ø¹ Ù‚ÙˆØ§Ø¹Ø¯ PDK."""
        errors = []
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙØ¬ÙˆØ©
        if params.gap < self.min_gap:
            errors.append(f"Ø§Ù„ÙØ¬ÙˆØ© {params.gap}Î¼m Ø£Ù‚Ù„ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ {self.min_gap}Î¼m")
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¹Ø±Ø¶
        if params.width < self.min_width:
            errors.append(f"Ø§Ù„Ø¹Ø±Ø¶ {params.width}Î¼m Ø£Ù‚Ù„ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ {self.min_width}Î¼m")
        if params.width > self.max_width:
            errors.append(f"Ø§Ù„Ø¹Ø±Ø¶ {params.width}Î¼m Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ {self.max_width}Î¼m")
        
        # ØªØ­Ù‚Ù‚ Ø®Ø§Øµ Ø¨Ù…Ù‚Ø³Ù…Ø§Øª Ø§Ù„Ø£Ø´Ø¹Ø©
        if params.gap < params.width * 0.3:
            warnings.warn(f"Ø§Ù„ÙØ¬ÙˆØ© ØµØºÙŠØ±Ø© Ø¬Ø¯Ø§Ù‹ Ù…Ù‚Ø§Ø±Ù†Ø© Ø¨Ø§Ù„Ø¹Ø±Ø¶: {params.gap/params.width:.1f}x")
        
        if errors:
            raise ValueError(f"Ø£Ø®Ø·Ø§Ø¡ ÙÙŠ Ø§Ù„ØªØµÙ…ÙŠÙ…:\n" + "\n".join(errors))

# ============================================================================
# Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© ÙˆÙ†Ù…Ø§Ø°Ø¬ Ø§Ø®ØªØ¨Ø§Ø±
# ============================================================================

def generate_coupler_test_structures(output_file: str = "coupler_test.gds"):
    """
    Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø§Ø®ØªØ¨Ø§Ø± Ù„Ù…Ù‚Ø³Ù…Ø§Øª Ø§Ù„Ø£Ø´Ø¹Ø© Ø§Ù„Ù…Ø®ØªÙ„ÙØ©.
    """
    library = gdspy.GdsLibrary()
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ù…ØµÙÙˆÙØ© Ù…Ù‚Ø³Ù…Ø§Øª Ø¨Ù…Ø®ØªÙ„Ù Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù†
    dc = QuantumDirectionalCoupler(layer=1)
    
    # 1. Ù…ØµÙÙˆÙØ© Ø§Ù„Ù…Ù‚Ø³Ù…Ø§Øª Ø§Ù„Ù…ØªÙˆØ§Ø²ÙŠØ©
    coupling_ratios = [0.1, 0.3, 0.5, 0.7, 0.9]
    multi_coupler = dc.create_multi_coupler_array(
        start_point=(0, 0),
        coupling_ratios=coupling_ratios,
        spacing=40.0
    )
    library.add(multi_coupler)
    
    # 2. Ù…Ù‚Ø³Ù… Ø´Ø¹Ø§Ø¹ 50:50 Ù…ØªÙˆØ§Ø²Ù†
    balanced_bs = dc.create_balanced_beam_splitter(
        center=(0, 50),
        design_type='50-50'
    )
    library.add(balanced_bs)
    
    # 3. Ù…Ù‚Ø³Ù… Ø´Ø¹Ø§Ø¹ Ù…Ù†Ø­Ù†ÙŠ
    curved_params = CouplerDesignParameters(
        coupling_ratio=0.5,
        length=30.0,
        gap=0.2,
        width=0.5,
        wavelength=1550.0,
        material='Si3N4'
    )
    curved_coupler = dc.create_curved_coupler(
        start_point=(0, 100),
        params=curved_params,
        bend_direction='up'
    )
    library.add(curved_coupler)
    
    # 4. Ù…Ù‚Ø³Ù…Ø§Øª Ø£Ø´Ø¹Ø© ØºÙŠØ± Ù…ØªÙ…Ø§Ø«Ù„Ø© (Ù„Ù‚ÙŠØ§Ø³Ø§Øª HOM)
    asym_coupler = dc.create_balanced_beam_splitter(
        center=(0, 150),
        design_type='asymmetric'
    )
    library.add(asym_coupler)
    
    # Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ù
    library.write_gds(output_file)
    print(f"ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±: {output_file}")
    
    # Ø¥Ù†Ø´Ø§Ø¡ ØªÙ‚Ø±ÙŠØ±
    report = f"""
    ØªÙ‚Ø±ÙŠØ± Ø§Ø®ØªØ¨Ø§Ø± Ù…Ù‚Ø³Ù…Ø§Øª Ø§Ù„Ø£Ø´Ø¹Ø©
    ===========================
    Ø§Ù„Ù…Ù„Ù: {output_file}
    Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ù‚Ø³Ù…Ø§Øª: {len(coupling_ratios) + 3}
    
    Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ù…Ù‚Ø³Ù…Ø§Øª:
    1. Ù…ØµÙÙˆÙØ© Ù…Ù‚Ø³Ù…Ø§Øª Ù…ØªÙˆØ§Ø²ÙŠØ© (Ù…Ø¹Ø§Ù…Ù„Ø§Øª: {coupling_ratios})
    2. Ù…Ù‚Ø³Ù… Ø´Ø¹Ø§Ø¹ Ù…ØªÙˆØ§Ø²Ù† 50:50
    3. Ù…Ù‚Ø³Ù… Ø´Ø¹Ø§Ø¹ Ù…Ù†Ø­Ù†ÙŠ
    4. Ù…Ù‚Ø³Ù… Ø´Ø¹Ø§Ø¹ ØºÙŠØ± Ù…ØªÙ…Ø§Ø«Ù„ (10:90)
    
    Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ù…Ø·Ø¨Ù‚Ø©:
    - Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„ÙØ¬ÙˆØ©: {dc.min_gap}Î¼m
    - Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø¹Ø±Ø¶: {dc.min_width}Î¼m
    - Ø·ÙˆÙ„ Ø§Ù„ØªØ¯Ø±Ø¬: {dc.taper_length}Î¼m
    - Ù†ØµÙ Ù‚Ø·Ø± Ø§Ù„Ø§Ù†Ø­Ù†Ø§Ø¡: {dc.bend_radius}Î¼m
    """
    
    with open("coupler_test_report.txt", "w", encoding="utf-8") as f:
        f.write(report)
    
    return library

def calculate_quantum_performance(params: CouplerDesignParameters) -> Dict:
    """
    Ø­Ø³Ø§Ø¨ Ø£Ø¯Ø§Ø¡ Ù…Ù‚Ø³Ù… Ø§Ù„Ø´Ø¹Ø§Ø¹ Ù„Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ©.
    
    ÙŠØ´Ù…Ù„:
    - Ø¥Ø®Ù„Ø§Øµ Ø§Ù„ØªØ´Ø§Ø¨Ùƒ (Bell state generation)
    - Ø±Ø¤ÙŠØ© ØªØ¯Ø§Ø®Ù„ HOM
    - Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø®Ø·Ø£ Ø§Ù„ÙƒÙ…ÙŠ
    """
    # Ù…Ø­Ø§ÙƒØ§Ø© Ù…Ø¨Ø³Ø·Ø© Ù„Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„ÙƒÙ…ÙŠ
    from scipy.special import erf
    
    # Ø¹ÙˆØ§Ù…Ù„ Ø§Ù„ØªØ£Ø«ÙŠØ±
    length_factor = np.exp(-0.001 * params.length)  # Ø®Ø³Ø§Ø¦Ø± Ø§Ù„Ø·ÙˆÙ„
    gap_factor = np.exp(-(params.gap - 0.15)**2 / 0.02)  # ØªØ£Ø«ÙŠØ± Ø§Ù„ÙØ¬ÙˆØ© Ø§Ù„Ù…Ø«Ù„Ù‰
    
    # Ø¥Ø®Ù„Ø§Øµ ØªÙˆÙ„ÙŠØ¯ Ø­Ø§Ù„Ø© Bell
    bell_fidelity = 0.99 * length_factor * gap_factor
    
    # Ø±Ø¤ÙŠØ© HOM (Ù„Ù„ÙÙˆØªÙˆÙ†Ø§Øª Ø§Ù„Ù…ØªØ·Ø§Ø¨Ù‚Ø©)
    hom_visibility = 0.95 * length_factor
    
    # Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø®Ø·Ø£ Ø§Ù„ÙƒÙ…ÙŠ (Ù„Ø¹Ù…Ù„ÙŠØ© unitar)
    quantum_error_rate = 0.001 * params.length * (1 + 2 * abs(params.coupling_ratio - 0.5))
    
    # Ø­Ø³Ø§Ø¨ Concurrence (Ù„Ù„ØªØ´Ø§Ø¨Ùƒ)
    concurrence = np.sqrt(params.coupling_ratio * (1 - params.coupling_ratio)) * 2
    
    return {
        'bell_state_fidelity': bell_fidelity,
        'hom_visibility': hom_visibility,
        'quantum_error_rate': quantum_error_rate,
        'concurrence': concurrence,
        'optimal_for_quantum': concurrence > 0.9,
        'recommended_applications': [
            "Bell state generation" if params.coupling_ratio â‰ˆ 0.5 else "Path encoding",
            "Quantum interferometry",
            "Single-photon routing"
        ]
    }

if __name__ == "__main__":
    # Ø§Ø®ØªØ¨Ø§Ø± Ù…Ø¨Ø§Ø´Ø± Ø¹Ù†Ø¯ Ø§Ù„ØªØ´ØºÙŠÙ„
    print("Ø§Ø®ØªØ¨Ø§Ø± Ù…Ù‚Ø³Ù… Ø§Ù„Ø´Ø¹Ø§Ø¹ Ø§Ù„ÙƒÙ…ÙŠ...")
        
    # Ù…Ø¹Ù„Ù…Ø§Øª Ø§Ø®ØªØ¨Ø§Ø±
    test_params = CouplerDesignParameters(
        coupling_ratio=0.5,
        length=20.0,
        gap=0.15,
        width=0.5,
        wavelength=1550.0,
        material='Si3N4'
    )
    
    # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ø¯Ø§Ø¡
    perf = calculate_quantum_performance(test_params)
    print(f"Ø¥Ø®Ù„Ø§Øµ Ø­Ø§Ù„Ø© Bell: {perf['bell_state_fidelity']:.4f}")
    print(f"Ø±Ø¤ÙŠØ© HOM: {perf['hom_visibility']:.4f}")
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø§Ø®ØªØ¨Ø§Ø±
    generate_coupler_test_structures("../layouts/test_couplers.gds")
    
    print("âœ… Ø§ÙƒØªÙ…Ù„ ØªØµÙ…ÙŠÙ… Ù…Ù‚Ø³Ù… Ø§Ù„Ø´Ø¹Ø§Ø¹ Ø§Ù„ÙƒÙ…ÙŠ")
```

ğŸ“Š Ù…Ø«Ø§Ù„ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø³Ø±ÙŠØ¹:

```python
# Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ÙƒØªØ¨Ø© ÙÙŠ Ø¯ÙØªØ± Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø£Ùˆ Ø³ÙƒØ±ÙŠØ¨Øª
from directional_coupler import QuantumDirectionalCoupler, CouplerDesignParameters

# 1. ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ù‚Ø³Ù…
dc = QuantumDirectionalCoupler(layer=1)

# 2. ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø¹Ù„Ù…Ø§Øª
params = CouplerDesignParameters(
    coupling_ratio=0.5,  # 50% Ø§Ù‚ØªØ±Ø§Ù†
    length=20.0,         # 20 Ù…ÙŠÙƒØ±ÙˆÙ†
    gap=0.15,           # 150 Ù†Ø§Ù†ÙˆÙ…ØªØ±
    width=0.5,          # 500 Ù†Ø§Ù†ÙˆÙ…ØªØ±
    wavelength=1550.0,
    material='Si3N4'
)

# 3. Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø³Ù… Ù…ØªÙˆØ§Ø²ÙŠ
parallel_coupler = dc.create_parallel_coupler(
    center=(100, 100),
    params=params,
    orientation='horizontal'
)

# 4. Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø³Ù… Ù…Ù†Ø­Ù†ÙŠ (Ù„Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø·ÙˆÙ„ Ø§Ù„ÙØ¹Ø§Ù„)
curved_coupler = dc.create_curved_coupler(
    start_point=(100, 200),
    params=params,
    bend_direction='up'
)

# 5. Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„ÙƒÙ…ÙŠ
quantum_perf = dc.calculate_quantum_performance(params)
print(f"Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„ÙƒÙ…ÙŠ: {quantum_perf}")
```

ğŸš€ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ© Ø§Ù„ØªÙ†ÙÙŠØ°ÙŠØ©:

Ù‚Ù… Ø¨ØªÙ†ÙÙŠØ° Ù‡Ø°Ù‡ Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¢Ù†:

```bash
# 1. Ø­ÙØ¸ Ù…Ù„Ù Ù…Ù‚Ø³Ù… Ø§Ù„Ø´Ø¹Ø§Ø¹
cd /QUANTUM_SOVEREIGN_CHIP
cp directional_coupler.py 03_FABRICATION/component_library/

# 2. Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„ØªØµÙ…ÙŠÙ…
cd 03_FABRICATION/component_library
python3 -c "
from directional_coupler import generate_coupler_test_structures
generate_coupler_test_structures('../layouts/test_couplers.gds')
print('ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù…Ù‚Ø³Ù…Ø§Øª')
"

# 3. Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù„Ù ÙÙŠ KLayout (Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ø«Ø¨ØªØ§Ù‹)
# klayout ../layouts/test_couplers.gds &
```

ğŸ“ˆ Ø­Ø§Ù„Ø© Ù…ÙƒØªØ¨Ø© Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©:

Ø§Ù„Ù…ÙƒÙˆÙ† Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ù„Ù Ù‚Ø§Ø¨Ù„ Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ âœ… Ù…ÙƒØªÙ…Ù„ waveguide.py Ù†Ø¹Ù…
Ù…Ù‚Ø³Ù… Ø§Ù„Ø´Ø¹Ø§Ø¹ âœ… Ù…ÙƒØªÙ…Ù„ Ø§Ù„Ø¢Ù† directional_coupler.py Ù†Ø¹Ù…
Ø§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ù†Ø§Ù†Ø© â³ Ù‚ÙŠØ¯ Ø§Ù„ØªØ·ÙˆÙŠØ± ring_resonator.py Ù‚Ø±ÙŠØ¨Ø§Ù‹
Ø§Ù„Ù…Ø³Ø®Ù† Ø§Ù„Ø­Ø±Ø§Ø±ÙŠ â³ Ù‚ÙŠØ¯ Ø§Ù„ØªØ·ÙˆÙŠØ± phase_shifter.py Ù‚Ø±ÙŠØ¨Ø§Ù‹
Ù…Ù‚Ø±Ù† Ø§Ù„Ù…Ø­Ø²ÙˆØ² â³ Ù‚ÙŠØ¯ Ø§Ù„ØªØ·ÙˆÙŠØ± grating_coupler.py Ù„Ø§Ø­Ù‚Ø§Ù‹