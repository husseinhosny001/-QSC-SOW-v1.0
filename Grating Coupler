Ù…Ù‚Ø±Ù† Ø§Ù„Ù…Ø­Ø²ÙˆØ² Ø§Ù„Ù…ØªÙ‚Ø¯Ù… (Grating Coupler) - Ù„Ù„Ø±Ù‚Ø§Ù‚Ø© Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ© Ø§Ù„Ø¶ÙˆØ¦ÙŠØ©

ğŸ“ Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠ ÙˆØ§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠ

1. Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ù…Ø­Ø²ÙˆØ²

Ù…Ù‚Ø±Ù† Ø§Ù„Ù…Ø­Ø²ÙˆØ² ÙŠØ­ÙˆÙ„ Ø§Ù„Ø¶ÙˆØ¡ Ù…Ù† Ø§Ù„Ø£Ù„ÙŠØ§Ù Ø¥Ù„Ù‰ Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ ÙÙŠ Ø§Ù„Ø±Ù‚Ø§Ù‚Ø© ÙˆØ§Ù„Ø¹ÙƒØ³. Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©:

n_{\text{eff}} = n_{\text{clad}} \sin(\theta) + \frac{m\lambda}{\Lambda}

Ø­ÙŠØ«:

Â·  n_{\text{eff}} : Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„Ø§Ù†ÙƒØ³Ø§Ø± Ø§Ù„ÙØ¹Ø§Ù„ Ù„Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ
Â·  n_{\text{clad}} : Ù…Ø¹Ø§Ù…Ù„ Ø§Ù†ÙƒØ³Ø§Ø± Ø§Ù„ØºØ·Ø§Ø¡ (Ø¹Ø§Ø¯Ø© SiOâ‚‚ = 1.44)
Â·  \theta : Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø³Ù‚ÙˆØ· (Ø¹Ø§Ø¯Ø© 8-12Â°)
Â·  m : Ø±ØªØ¨Ø© Ø§Ù„Ù…Ø­Ø²ÙˆØ² (Ø¹Ø§Ø¯Ø© m=1)
Â·  \lambda : Ø§Ù„Ø·ÙˆÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ (1550 Ù†Ø§Ù†ÙˆÙ…ØªØ±)
Â·  \Lambda : Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø­Ø²ÙˆØ²

2. Ù…Ù„Ù Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„ÙƒØ§Ù…Ù„

Ù…Ù„Ù: /03_FABRICATION/component_library/grating_coupler.py

```python
"""
Ù…Ù‚Ø±Ù† Ù…Ø­Ø²ÙˆØ² Ù…ØªÙ‚Ø¯Ù… Ù„Ù„Ø±Ù‚Ø§Ù‚Ø© Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ© Ø§Ù„Ø¶ÙˆØ¦ÙŠØ©.
ÙŠØ¯Ø¹Ù…: ØªØµÙ…ÙŠÙ… Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ø£Ø·ÙˆØ§Ù„ Ø§Ù„Ù…ÙˆØ¬ÙŠØ©ØŒ ØªØ­Ø³ÙŠÙ† Ø§Ù„ÙƒÙØ§Ø¡Ø©ØŒ ÙˆØ¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø§Ø³ØªÙ‚Ø·Ø§Ø¨.
"""
import numpy as np
import gdspy
import yaml
from typing import Tuple, List, Dict, Optional
import json
from dataclasses import dataclass
from math import sin, cos, tan, radians, degrees, sqrt

@dataclass
class GratingDesignParameters:
    """Ù…Ø¹Ù„Ù…Ø§Øª ØªØµÙ…ÙŠÙ… Ø§Ù„Ù…Ø­Ø²ÙˆØ²."""
    wavelength: float = 1.55  # Î¼m
    wavelength_bandwidth: float = 0.04  # Â±40 nm
    angle_of_incidence: float = 10.0  # Ø¯Ø±Ø¬Ø§Øª
    polarization: str = "TE"  # TE Ø£Ùˆ TM
    target_efficiency: float = 0.6  # 60% ÙƒÙØ§Ø¡Ø©
    material_system: str = "Si3N4_SiO2"  # Siâ‚ƒNâ‚„ Ø¹Ù„Ù‰ SiOâ‚‚
    
    # Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ø§Ù†ÙƒØ³Ø§Ø± @ 1550nm
    n_core: float = 2.0      # Siâ‚ƒNâ‚„
    n_cladding: float = 1.44  # SiOâ‚‚
    n_superstrate: float = 1.0  # Ù‡ÙˆØ§Ø¡
    
    # Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„Ø·Ø¨Ù‚Ø©
    core_thickness: float = 0.22  # Î¼m
    etch_depth: float = 0.11      # Î¼m (Ù†ØµÙ Ø§Ù„Ø³Ù…Ø§ÙƒØ©)
    
    # Ù…Ø¹Ù„Ù…Ø§Øª Ø§Ù„Ù…Ø­Ø²ÙˆØ²
    grating_period: Optional[float] = None  # Ø³ØªØ­Ø³Ø¨ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
    fill_factor: float = 0.5      # Ù†Ø³Ø¨Ø© Ø§Ù„Ø³Ù†Ø§Ù† Ø¥Ù„Ù‰ Ø§Ù„ÙØ±Ø§Øº
    number_of_periods: int = 20   # Ø¹Ø¯Ø¯ Ø§Ù„Ø¯ÙˆØ±Ø§Øª
    tooth_width: Optional[float] = None
    gap_width: Optional[float] = None

class AdvancedGratingCoupler:
    """Ù…Ù‚Ø±Ù† Ù…Ø­Ø²ÙˆØ² Ù…ØªÙ‚Ø¯Ù… Ù…Ø¹ ØªØ­Ø³ÙŠÙ†Ø§Øª Ù„Ù„ÙƒÙØ§Ø¡Ø© ÙˆØ¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø§Ø³ØªÙ‚Ø·Ø§Ø¨."""
    
    def __init__(self, params: GratingDesignParameters = None):
        self.params = params or GratingDesignParameters()
        self._calculate_design_parameters()
        
        # ØªØ­Ù…ÙŠÙ„ Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØµÙ…ÙŠÙ…
        with open('../PDK/design_rules.yaml', 'r') as f:
            self.drc = yaml.safe_load(f)
        
        # Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©
        self.simulation_results = {}
        self.geometry_cells = {}
    
    def _calculate_design_parameters(self):
        """Ø­Ø³Ø§Ø¨ Ù…Ø¹Ù„Ù…Ø§Øª Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©."""
        Î» = self.params.wavelength
        Î¸ = radians(self.params.angle_of_incidence)
        
        # 1. Ø­Ø³Ø§Ø¨ Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø­Ø²ÙˆØ² Ù…Ù† Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ù…Ø­Ø²ÙˆØ²
        # n_eff = n_clad * sin(Î¸) + m * Î» / Î›
        # Ù†ÙØªØ±Ø¶ m = 1 Ù„Ù„Ø±ØªØ¨Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰
        
        # ØªÙ‚Ø¯ÙŠØ± n_eff Ù„Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ Siâ‚ƒNâ‚„ 220nm
        n_eff_approx = 1.7  # Ù‚ÙŠÙ…Ø© ØªÙ‚Ø±ÙŠØ¨ÙŠØ© Ù„Ù€ Siâ‚ƒNâ‚„ 220nm @ 1550nm
        
        self.params.grating_period = Î» / (
            n_eff_approx - self.params.n_cladding * sin(Î¸)
        )
        
        # 2. Ø­Ø³Ø§Ø¨ Ø¹Ø±Ø¶ Ø§Ù„Ø³Ù† ÙˆØ§Ù„ÙØ±Ø§Øº
        if self.params.tooth_width is None:
            self.params.tooth_width = (
                self.params.grating_period * self.params.fill_factor
            )
        
        if self.params.gap_width is None:
            self.params.gap_width = (
                self.params.grating_period - self.params.tooth_width
            )
        
        # 3. Ø­Ø³Ø§Ø¨ Ø§Ù„Ø·ÙˆÙ„ Ø§Ù„ÙƒÙ„ÙŠ
        self.total_length = (
            self.params.number_of_periods * self.params.grating_period
        )
        
        # 4. Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¹Ø±Ø¶ (Ø¹Ù„Ù‰ Ø£Ø³Ø§Ø³ Ø¹Ø±Ø¶ Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ + ØªÙˆØ³ÙŠØ¹)
        self.taper_width_start = 0.5  # Î¼m (Ø¹Ø±Ø¶ Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ)
        self.taper_width_end = 12.0   # Î¼m (Ø¹Ø±Ø¶ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…Ø­Ø²ÙˆØ²)
        
        print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        print("  Ù…Ø¹Ù„Ù…Ø§Øª ØªØµÙ…ÙŠÙ… Ù…Ù‚Ø±Ù† Ø§Ù„Ù…Ø­Ø²ÙˆØ² Ø§Ù„Ù…Ø­Ø³ÙˆØ¨Ø©")
        print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        print(f"â€¢ Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø­Ø²ÙˆØ² (Î›): {self.params.grating_period:.3f} Î¼m")
        print(f"â€¢ Ø¹Ø±Ø¶ Ø§Ù„Ø³Ù†: {self.params.tooth_width:.3f} Î¼m")
        print(f"â€¢ Ø¹Ø±Ø¶ Ø§Ù„ÙØ±Ø§Øº: {self.params.gap_width:.3f} Î¼m")
        print(f"â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ø¯ÙˆØ±Ø§Øª: {self.params.number_of_periods}")
        print(f"â€¢ Ø§Ù„Ø·ÙˆÙ„ Ø§Ù„ÙƒÙ„ÙŠ: {self.total_length:.1f} Î¼m")
        print(f"â€¢ Ù†Ø³Ø¨Ø© Ø§Ù„Ù…Ù„Ø¡: {self.params.fill_factor:.1%}")
        print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    
    def create_grating_structure(self, position: Tuple[float, float] = (0, 0),
                                orientation: str = "input") -> gdspy.Cell:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ù…Ø­Ø²ÙˆØ² Ø§Ù„ÙƒØ§Ù…Ù„.
        
        Args:
            position: Ù…ÙˆØ¶Ø¹ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© (x, y)
            orientation: "input" Ø£Ùˆ "output" (ÙŠØ­Ø¯Ø¯ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„ØªØ¯Ø±Ø¬)
            
        Returns:
            Ø®Ù„ÙŠØ© GDS ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø­Ø²ÙˆØ²
        """
        cell = gdspy.Cell(f"GC_{orientation}_{self.params.wavelength}nm")
        
        # 1. Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„ØªØ¯Ø±Ø¬ (Taper)
        taper = self._create_taper_section(position, orientation)
        cell.add(taper)
        
        # 2. Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…Ø­Ø²ÙˆØ²
        grating_start = (
            position[0] + (10 if orientation == "input" else 0),
            position[1]
        )
        
        grating_cell = self._create_grating_teeth(grating_start, orientation)
        cell.add(grating_cell)
        
        # 3. Ø¥Ø¶Ø§ÙØ© Ø¹Ù„Ø§Ù…Ø§Øª Ù…Ø­Ø§Ø°Ø§Ø© ÙˆÙ…Ø­Ø§Ø°Ø§Ø© Ø¨ØµØ±ÙŠØ©
        alignment = self._create_alignment_marks(position)
        cell.add(alignment)
        
        # 4. Ø¥Ø¶Ø§ÙØ© Ù†ØµÙˆØµ ØªØ¹Ø±ÙŠÙÙŠØ©
        text = self._add_design_labels(position)
        cell.add(text)
        
        return cell
    
    def _create_taper_section(self, start_pos: Tuple[float, float],
                             orientation: str) -> gdspy.PolygonSet:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„ØªØ¯Ø±Ø¬ Ù…Ù† Ø¹Ø±Ø¶ Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ Ø¥Ù„Ù‰ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø­Ø²ÙˆØ².
        
        Ø§Ù„ØªØ¯Ø±Ø¬ Ø§Ù„Ø®Ø·ÙŠ: w(z) = w_start + (w_end - w_start) * (z/L)
        """
        taper_length = 100.0  # Î¼m
        
        # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§ØªØ¬Ø§Ù‡
        if orientation == "input":
            # Ù…Ù† Ø§Ù„Ù…Ø­Ø²ÙˆØ² Ø¥Ù„Ù‰ Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ
            width_start = self.taper_width_end
            width_end = self.taper_width_start
            x_start, y_start = start_pos
            x_end = x_start - taper_length
        else:  # output
            # Ù…Ù† Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø­Ø²ÙˆØ²
            width_start = self.taper_width_start
            width_end = self.taper_width_end
            x_start, y_start = start_pos
            x_end = x_start + taper_length
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¶Ù„Ø¹ Ø§Ù„ØªØ¯Ø±Ø¬
        points = [
            (x_start, y_start + width_start/2),
            (x_start, y_start - width_start/2),
            (x_end, y_start - width_end/2),
            (x_end, y_start + width_end/2)
        ]
        
        taper = gdspy.Polygon(points, layer=self._get_layer("waveguide"))
        
        # Ø¥Ø¶Ø§ÙØ© ØªØ¯Ø±Ø¬ Ù…ÙØµÙ„ (Ù„ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø®Ø³Ø§Ø¦Ø±)
        detailed_taper = self._create_detailed_taper(
            start_pos, taper_length, width_start, width_end, orientation
        )
        
        return detailed_taper if detailed_taper else taper
    
    def _create_detailed_taper(self, start_pos: Tuple[float, float],
                              length: float, w1: float, w2: float,
                              orientation: str) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ ØªØ¯Ø±Ø¬ Ù…ÙØµÙ‘Ù„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ù†Ø­Ù†ÙŠØ§Øª Ø¬ÙŠØ¨ÙŠØ© Ù„ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø®Ø³Ø§Ø¦Ø±."""
        cell = gdspy.Cell("DetailedTaper")
        
        # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ù†Ø­Ù†Ù‰ Ø¬ÙŠØ¨ÙŠ Ù„Ù„ØªØ¯Ø±Ø¬: w(z) = w1 + (w2-w1) * sinÂ²(Ï€z/2L)
        num_segments = 20
        segment_length = length / num_segments
        
        for i in range(num_segments):
            z1 = i * segment_length
            z2 = (i + 1) * segment_length
            
            # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¹Ø±Ø¶ Ø¹Ù†Ø¯ ÙƒÙ„ Ù†Ù‚Ø·Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ù†Ø­Ù†Ù‰ Ø¬ÙŠØ¨ÙŠ
            width1 = w1 + (w2 - w1) * (sin(radians(90 * z1 / length)) ** 2)
            width2 = w1 + (w2 - w1) * (sin(radians(90 * z2 / length)) ** 2)
            
            # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø§ØªØ¬Ø§Ù‡
            if orientation == "input":
                x1 = start_pos[0] - z1
                x2 = start_pos[0] - z2
            else:
                x1 = start_pos[0] + z1
                x2 = start_pos[0] + z2
            
            y = start_pos[1]
            
            # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø·Ø¹ Ø§Ù„ØªØ¯Ø±Ø¬
            points = [
                (x1, y + width1/2),
                (x1, y - width1/2),
                (x2, y - width2/2),
                (x2, y + width2/2)
            ]
            
            segment = gdspy.Polygon(points, layer=self._get_layer("waveguide"))
            cell.add(segment)
        
        return cell
    
    def _create_grating_teeth(self, start_pos: Tuple[float, float],
                             orientation: str) -> gdspy.Cell:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø³Ù†Ø§Ù† Ø§Ù„Ù…Ø­Ø²ÙˆØ² Ù…Ø¹ ØªØ¯Ø±Ø¬ ÙÙŠ Ø§Ù„Ø¯ÙˆØ±Ø© Ù„Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„ØªØ±Ø¯Ø¯ÙŠ.
        
        Ø§Ø³ØªØ®Ø¯Ø§Ù… ØªØ¯Ø±Ø¬ Ø§Ù„Ø®Ø·ÙŠ ÙÙŠ Ø§Ù„Ø¯ÙˆØ±Ø©: Î›(z) = Î›â‚€ + Î±*z
        """
        cell = gdspy.Cell("GratingTeeth")
        
        Î›0 = self.params.grating_period  # Ø§Ù„Ø¯ÙˆØ±Ø© Ø¹Ù†Ø¯ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
        Î± = 0.002  # Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„ØªØ¯Ø±Ø¬ (0.2% Ø²ÙŠØ§Ø¯Ø© Ù„ÙƒÙ„ Ù…ÙŠÙƒØ±ÙˆÙ…ØªØ±)
        
        # Ù…Ø¹Ù„Ù…Ø§Øª Ø§Ù„ØªØµÙ…ÙŠÙ…
        tooth_width = self.params.tooth_width
        fill_factor = self.params.fill_factor
        
        current_x = start_pos[0]
        y_center = start_pos[1]
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„ÙƒÙ„ÙŠ Ù„Ù„Ù…Ø­Ø²ÙˆØ² (ÙŠØªÙ†Ø§Ù‚Øµ Ù…Ø¹ Ø§Ù„Ù…Ø³Ø§ÙØ©)
        grating_width = self.taper_width_end
        
        for i in range(self.params.number_of_periods):
            # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¯ÙˆØ±Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù…Ø¹ Ø§Ù„ØªØ¯Ø±Ø¬
            current_period = Î›0 * (1 + Î± * i)
            
            # Ø­Ø³Ø§Ø¨ Ø¹Ø±Ø¶ Ø§Ù„Ø³Ù† ÙˆØ§Ù„ÙØ±Ø§Øº Ø§Ù„Ø­Ø§Ù„ÙŠÙŠÙ†
            current_tooth = current_period * fill_factor
            current_gap = current_period * (1 - fill_factor)
            
            # ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø³Ù†
            tooth_x_start = current_x
            tooth_x_end = tooth_x_start + current_tooth
            
            # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø³Ù† (Ù…Ø³ØªØ·ÙŠÙ„)
            tooth_points = [
                (tooth_x_start, y_center - grating_width/2),
                (tooth_x_start, y_center + grating_width/2),
                (tooth_x_end, y_center + grating_width/2),
                (tooth_x_end, y_center - grating_width/2)
            ]
            
            tooth = gdspy.Polygon(tooth_points, layer=self._get_layer("waveguide"))
            cell.add(tooth)
            
            # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù„Ù„Ø¯ÙˆØ±Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©
            current_x += current_period
            
            # ØªÙ‚Ù„ÙŠÙ„ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø­Ø²ÙˆØ² ØªØ¯Ø±ÙŠØ¬ÙŠØ§Ù‹ (Ù„ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø§Ù†ØªØ´Ø§Ø± Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠ)
            if i % 5 == 0 and i > 0:
                grating_width *= 0.95
        
        return cell
    
    def _create_alignment_marks(self, position: Tuple[float, float]) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ù„Ø§Ù…Ø§Øª Ù…Ø­Ø§Ø°Ø§Ø© Ù„Ù„ØªØµÙ†ÙŠØ¹ ÙˆØ§Ù„Ø§Ø®ØªØ¨Ø§Ø±."""
        cell = gdspy.Cell("AlignmentMarks")
        
        # Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ù…Ø­Ø§Ø°Ø§Ø© Ø§Ù„Ø¨ØµØ±ÙŠØ© (Ù„Ø¶Ø¨Ø· Ø§Ù„Ø£Ù„ÙŠØ§Ù)
        mark_size = 5.0  # Î¼m
        
        # Ø¹Ù„Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø´ÙƒÙ„ ØµÙ„ÙŠØ¨
        cross_center = (position[0] + 50, position[1])
        
        # Ø§Ù„Ø®Ø· Ø§Ù„Ø£ÙÙ‚ÙŠ
        h_line = gdspy.Rectangle(
            (cross_center[0] - mark_size/2, cross_center[1] - 0.1),
            (cross_center[0] + mark_size/2, cross_center[1] + 0.1),
            layer=self._get_layer("alignment")
        )
        
        # Ø§Ù„Ø®Ø· Ø§Ù„Ø±Ø£Ø³ÙŠ
        v_line = gdspy.Rectangle(
            (cross_center[0] - 0.1, cross_center[1] - mark_size/2),
            (cross_center[0] + 0.1, cross_center[1] + mark_size/2),
            layer=self._get_layer("alignment")
        )
        
        # Ø¯Ø§Ø¦Ø±Ø© Ù…Ø±ÙƒØ²ÙŠØ©
        circle = gdspy.Round(
            cross_center,
            mark_size/4,
            layer=self._get_layer("alignment")
        )
        
        # Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ù…Ø³Ø§ÙØ©
        for offset in [-20, 0, 20]:
            distance_mark = gdspy.Rectangle(
                (cross_center[0] + offset, cross_center[1] - 1),
                (cross_center[0] + offset, cross_center[1] + 1),
                layer=self._get_layer("alignment")
            )
            cell.add(distance_mark)
        
        cell.add([h_line, v_line, circle])
        
        return cell
    
    def _add_design_labels(self, position: Tuple[float, float]) -> gdspy.Cell:
        """Ø¥Ø¶Ø§ÙØ© Ù†ØµÙˆØµ ØªØ¹Ø±ÙŠÙÙŠØ© ÙˆØªØµÙ…ÙŠÙ…ÙŠØ©."""
        cell = gdspy.Cell("DesignLabels")
        
        text_params = {
            "layer": self._get_layer("text"),
            "magnification": 10
        }
        
        # Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
        info_lines = [
            f"GC Design v1.0",
            f"Î»={self.params.wavelength}Î¼m, Î¸={self.params.angle_of_incidence}Â°",
            f"Î›={self.params.grating_period:.3f}Î¼m, FF={self.params.fill_factor:.1%}",
            f"Material: {self.params.material_system}",
            f"Polarization: {self.params.polarization}"
        ]
        
        y_offset = position[1] + 15
        
        for i, line in enumerate(info_lines):
            text = gdspy.Text(
                line,
                2,  # Ø­Ø¬Ù… Ø§Ù„Ø®Ø·
                (position[0] - 10, y_offset - i * 3),
                **text_params
            )
            cell.add(text)
        
        # Ø¥Ø´Ø§Ø±Ø© Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¶ÙˆØ¡
        arrow_points = [
            (position[0] + 60, position[1]),
            (position[0] + 80, position[1]),
            (position[0] + 75, position[1] + 2),
            (position[0] + 80, position[1]),
            (position[0] + 75, position[1] - 2)
        ]
        
        arrow = gdspy.Polygon(arrow_points, layer=self._get_layer("text"))
        cell.add(arrow)
        
        arrow_text = gdspy.Text(
            "Light",
            3,
            (position[0] + 85, position[1] - 1),
            **text_params
        )
        cell.add(arrow_text)
        
        return cell
    
    def _get_layer(self, layer_type: str) -> int:
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø±Ù‚Ù… Ø§Ù„Ø·Ø¨Ù‚Ø© Ù…Ù† Ù†ÙˆØ¹Ù‡Ø§."""
        layer_map = {
            "waveguide": 1,      # Siâ‚ƒNâ‚„
            "nonlinear": 2,      # AlGaAs
            "heater": 10,        # TiN
            "via": 11,           # Ti
            "alignment": 0,      # Ø¹Ù„Ø§Ù…Ø§Øª Ù…Ø­Ø§Ø°Ø§Ø©
            "text": 100,         # Ù†ØµÙˆØµ
            "simulation": 200    # Ù…Ù†Ø§Ø·Ù‚ Ù…Ø­Ø§ÙƒØ§Ø©
        }
        
        return layer_map.get(layer_type, 1)
    
    def create_array_coupler(self, position: Tuple[float, float],
                           num_ports: int = 8,
                           spacing: float = 127.0) -> gdspy.Cell:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ù…ØµÙÙˆÙØ© Ù…Ù† Ù…Ù‚Ø±Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø²ÙˆØ² Ù„Ù„Ø¯Ø®Ù„/Ø®Ø±Ø¬ Ù…ØªØ¹Ø¯Ø¯Ø©.
        
        Args:
            position: Ù…ÙˆØ¶Ø¹ Ø£ÙˆÙ„ Ù…Ù‚Ø±Ù†
            num_ports: Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ù†Ø§ÙØ°
            spacing: Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø§Ù„Ù…Ù†Ø§ÙØ° (Ø¹Ø§Ø¯Ø© 127Î¼m Ù„ØªØ·Ø§Ø¨Ù‚ Ø§Ù„Ø£Ù„ÙŠØ§Ù)
            
        Returns:
            Ø®Ù„ÙŠØ© ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù…ØµÙÙˆÙØ© ÙƒØ§Ù…Ù„Ø©
        """
        cell = gdspy.Cell(f"GratingCoupler_Array_{num_ports}ports")
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø±Ù†Ø§Øª ÙØ±Ø¯ÙŠØ©
        for i in range(num_ports):
            port_pos = (
                position[0],
                position[1] + i * spacing
            )
            
            # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ (Ù…Ø¯Ø®Ù„Ø§Øª ÙØ±Ø¯ÙŠØ©ØŒ Ù…Ø®Ø§Ø±Ø¬ Ø²ÙˆØ¬ÙŠØ©)
            orientation = "input" if i % 2 == 0 else "output"
            
            # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ù‚Ø±Ù† Ø§Ù„ÙØ±Ø¯ÙŠ
            gc_cell = self.create_grating_structure(port_pos, orientation)
            
            # Ø¥Ø¶Ø§ÙØ© ÙˆØµÙ„Ø© Ø¥Ù„Ù‰ Ø´Ø¨ÙƒØ© Ø§Ù„Ø¯ÙˆØ§Ø¦Ø± Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ©
            waveguide = self._connect_to_internal_circuit(port_pos, orientation)
            
            cell.add(gc_cell)
            cell.add(waveguide)
            
            # Ø¥Ø¶Ø§ÙØ© ØªØ³Ù…ÙŠØ© Ø§Ù„Ù…Ù†ÙØ°
            port_label = gdspy.Text(
                f"Port_{i+1}",
                4,
                (port_pos[0] - 15, port_pos[1]),
                layer=self._get_layer("text")
            )
            cell.add(port_label)
        
        # Ø¥Ø¶Ø§ÙØ© Ø¥Ø·Ø§Ø± ÙˆÙ…Ø­Ø§Ø°Ø§Ø© Ù„Ù„Ù…ØµÙÙˆÙØ©
        frame = self._create_array_frame(position, num_ports, spacing)
        cell.add(frame)
        
        return cell
    
    def _connect_to_internal_circuit(self, port_pos: Tuple[float, float],
                                    orientation: str) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ ÙˆØµÙ„Ø© Ù…Ù† Ø§Ù„Ù…Ø­Ø²ÙˆØ² Ø¥Ù„Ù‰ Ø§Ù„Ø¯ÙˆØ§Ø¦Ø± Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ©."""
        cell = gdspy.Cell(f"Waveguide_Connection")
        
        # Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© (Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…Ø­Ø²ÙˆØ²)
        if orientation == "input":
            start_point = (port_pos[0] - self.total_length - 100, port_pos[1])
        else:
            start_point = (port_pos[0] + self.total_length + 100, port_pos[1])
        
        # Ù†Ù‚Ø·Ø© Ø§Ù„Ù†Ù‡Ø§ÙŠØ© (Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø¯ÙˆØ§Ø¦Ø± Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ©)
        end_point = (start_point[0] + (150 if orientation == "input" else -150), 
                    start_point[1])
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø¯Ù„ÙŠÙ„ Ù…ÙˆØ¬ÙŠ Ù…Ø¹ Ù…Ù†Ø¹Ø·ÙØ§Øª Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªØ¯Ø§Ø®Ù„
points = self._calculate_waveguide_path(start_point, end_point)
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ ÙƒØ®Ø· Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡
        waveguide = gdspy.FlexPath(
            points,
            width=0.5,  # Ø¹Ø±Ø¶ Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ
            corners="circular",  # Ù…Ù†Ø¹Ø·ÙØ§Øª Ø¯Ø§Ø¦Ø±ÙŠØ©
            bend_radius=20.0,    # Ù†ØµÙ Ù‚Ø·Ø± Ø§Ù„Ø§Ù†Ø­Ù†Ø§Ø¡
            layer=self._get_layer("waveguide"),
            gdsii_path=True
        )
        
        cell.add(waveguide)
        
        return cell
    
    def _calculate_waveguide_path(self, start: Tuple[float, float],
                                 end: Tuple[float, float]) -> List[Tuple[float, float]]:
        """Ø­Ø³Ø§Ø¨ Ù…Ø³Ø§Ø± Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ Ø§Ù„Ø£Ù…Ø«Ù„ Ù…Ø¹ Ù…Ù†Ø¹Ø·ÙØ§Øª."""
        # Ø·Ø±ÙŠÙ‚Ø© Ø¨Ø³ÙŠØ·Ø©: Ø®Ø· Ù…Ø³ØªÙ‚ÙŠÙ… Ù…Ø¹ Ù…Ù†Ø¹Ø·ÙØ§Øª Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©
        x1, y1 = start
        x2, y2 = end
        
        # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³Ø§Ø± Ø±Ø£Ø³ÙŠØ§Ù‹ Ø¨Ø´ÙƒÙ„ Ø£Ø³Ø§Ø³ÙŠØŒ Ø§Ø³ØªØ®Ø¯Ù… Ù…Ù†Ø¹Ø·ÙØ§Øª
        if abs(y2 - y1) > 50:
            points = [
                start,
                (x1 + 20, y1),           # Ø¬Ø²Ø¡ Ø£ÙÙ‚ÙŠ
                (x1 + 20, (y1 + y2)/2),  # Ø¬Ø²Ø¡ Ø±Ø£Ø³ÙŠ
                (x2 - 20, (y1 + y2)/2),  # Ø¬Ø²Ø¡ Ø£ÙÙ‚ÙŠ
                (x2 - 20, y2),           # Ø¬Ø²Ø¡ Ø±Ø£Ø³ÙŠ
                end
            ]
        else:
            points = [start, end]
        
        return points
    
    def _create_array_frame(self, position: Tuple[float, float],
                          num_ports: int, spacing: float) -> gdspy.Polygon:
        """Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø·Ø§Ø± Ø­ÙˆÙ„ Ù…ØµÙÙˆÙØ© Ø§Ù„Ù…Ù‚Ø±Ù†Ø§Øª."""
        frame_margin = 50  # Î¼m
        
        frame_width = 100
        frame_height = (num_ports - 1) * spacing + 2 * frame_margin
        
        frame_points = [
            (position[0] - frame_margin, position[1] - frame_margin),
            (position[0] - frame_margin, position[1] + frame_height - frame_margin),
            (position[0] + frame_width, position[1] + frame_height - frame_margin),
            (position[0] + frame_width, position[1] - frame_margin)
        ]
        
        frame = gdspy.Polygon(frame_points, layer=self._get_layer("alignment"))
        
        return frame
    
    def simulate_performance(self) -> Dict:
        """
        Ù…Ø­Ø§ÙƒØ§Ø© Ø£Ø¯Ø§Ø¡ Ù…Ù‚Ø±Ù† Ø§Ù„Ù…Ø­Ø²ÙˆØ² (Ø´Ø¨Ù‡ ØªØ­Ù„ÙŠÙ„ÙŠ).
        
        Returns:
            Ù‚Ø§Ù…ÙˆØ³ Ø¨Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©
        """
        # Ù‡Ø°Ø§ ØªÙ†ÙÙŠØ° Ù…Ø¨Ø³Ø· - ÙÙŠ Ø§Ù„ÙˆØ§Ù‚Ø¹ ØªØ­ØªØ§Ø¬ Ù…Ø­Ø§ÙƒØ§Ø© FDTD ÙƒØ§Ù…Ù„Ø©
        
        Î» = self.params.wavelength
        Î› = self.params.grating_period
        N = self.params.number_of_periods
        Î¸ = self.params.angle_of_incidence
        
        # 1. Ø­Ø³Ø§Ø¨ ÙƒÙØ§Ø¡Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù† (ØµÙŠØºØ© ØªÙ‚Ø±ÙŠØ¨ÙŠØ©)
        # Î· â‰ˆ sincÂ²(Î”Î² * L/2) Ø­ÙŠØ« Î”Î² Ù‡Ùˆ Ø¹Ø¯Ù… Ø§Ù„ØªØ·Ø§Ø¨Ù‚ ÙÙŠ Ù…ØªØ¬Ù‡ Ø§Ù„Ù…ÙˆØ¬Ø©
        Î”Î² = 2 * np.pi * (1/Î› - self.params.n_eff/Î» + self.params.n_cladding*sin(radians(Î¸))/Î»)
        L = N * Î›
        Î·_coupling = (np.sinc(Î”Î² * L / (2 * np.pi))) ** 2
        
        # 2. Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„ØªØ±Ø¯Ø¯ÙŠ (FWHM)
        Î”Î»_FWHM = Î» / N
        
        # 3. Ø­Ø³Ø§Ø¨ Ø®Ø³Ø§Ø¦Ø± Ø§Ù„Ø¹ÙˆØ¯Ø© (Back-reflection)
        R_back = 0.05 * (1 - Î·_coupling)  # ØªÙ‚Ø±ÙŠØ¨
        
        # 4. Ø­Ø³Ø§Ø¨ Ø®Ø³Ø§Ø¦Ø± Ø§Ù„Ø§Ù†ØªØ´Ø§Ø± (Ø§Ù„Ø§Ù†ØªØ´Ø§Ø± Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠ)
        # ØªØ²Ø¯Ø§Ø¯ Ù…Ø¹ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø­Ø²ÙˆØ² ÙˆØ·ÙˆÙ„ Ø§Ù„ØªØ¯Ø±Ø¬
       Î·_taper = 1 - 0.1 * (self.taper_width_end / 10) ** 2
        
        # Ø§Ù„ÙƒÙØ§Ø¡Ø© Ø§Ù„ÙƒÙ„ÙŠØ©
        Î·_total = Î·_coupling * Î·_taper * (1 - R_back)
        
        self.simulation_results = {
            "coupling_efficiency": float(Î·_total),
            "coupling_efficiency_dB": float(-10 * np.log10(Î·_total) if Î·_total > 0 else 100),
            "bandwidth_3dB_nm": float(Î”Î»_FWHM * 1000),  # ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ nm
            "back_reflection": float(R_back),
            "optimal_wavelength_nm": float(Î» * 1000),
            "angular_tolerance_deg": float(2.0),  # Â±2Â°
            "polarization_dependence_dB": float(0.5 if self.params.polarization == "TE" else 1.0),
            "estimated_insertion_loss_dB": float(-10 * np.log10(Î·_total)),
            "simulation_notes": "Ù…Ø­Ø§ÙƒØ§Ø© Ø´Ø¨Ù‡ ØªØ­Ù„ÙŠÙ„ÙŠØ© - ØªØ­ØªØ§Ø¬ ØªØ­Ù‚Ù‚ Ø¨Ù…Ø­Ø§ÙƒØ§Ø© FDTD"
        }
        
        return self.simulation_results
    
    def generate_design_report(self) -> str:
        """ØªÙˆÙ„ÙŠØ¯ ØªÙ‚Ø±ÙŠØ± ØªØµÙ…ÙŠÙ… Ù…ÙØµÙ„."""
        report = f"""
        ===================================================
        ØªÙ‚Ø±ÙŠØ± ØªØµÙ…ÙŠÙ… Ù…Ù‚Ø±Ù† Ø§Ù„Ù…Ø­Ø²ÙˆØ² Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠ
        ===================================================
        
        Ù¡. Ø§Ù„Ù…Ø¹Ù„Ù…Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©:
           â€¢ Ø§Ù„Ø·ÙˆÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ: {self.params.wavelength} Î¼m ({self.params.wavelength*1000:.1f} nm)
           â€¢ Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø³Ù‚ÙˆØ·: {self.params.angle_of_incidence}Â°
           â€¢ Ø§Ù„Ø§Ø³ØªÙ‚Ø·Ø§Ø¨: {self.params.polarization}
           â€¢ Ø§Ù„Ù…Ø§Ø¯Ø©: {self.params.material_system}
        
        Ù¢. Ù…Ø¹Ù„Ù…Ø§Øª Ø§Ù„Ù…Ø­Ø²ÙˆØ²:
           â€¢ Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø­Ø²ÙˆØ² (Î›): {self.params.grating_period:.3f} Î¼m
           â€¢ Ù†Ø³Ø¨Ø© Ø§Ù„Ù…Ù„Ø¡: {self.params.fill_factor:.1%}
           â€¢ Ø¹Ø±Ø¶ Ø§Ù„Ø³Ù†: {self.params.tooth_width:.3f} Î¼m
           â€¢ Ø¹Ø¯Ø¯ Ø§Ù„Ø¯ÙˆØ±Ø§Øª: {self.params.number_of_periods}
           â€¢ Ø§Ù„Ø·ÙˆÙ„ Ø§Ù„ÙƒÙ„ÙŠ: {self.total_length:.1f} Î¼m
        
        Ù£. Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„ØªØ¯Ø±Ø¬:
           â€¢ Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ØªØ¯Ø±Ø¬: {self.taper_width_start} Î¼m
           â€¢ Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ØªØ¯Ø±Ø¬: {self.taper_width_end} Î¼m
           â€¢ Ø·ÙˆÙ„ Ø§Ù„ØªØ¯Ø±Ø¬: 100 Î¼m
        
        Ù¤. Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©:
           â€¢ ÙƒÙØ§Ø¡Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù†: {self.simulation_results.get('coupling_efficiency', 0):.1%}
           â€¢ Ø®Ø³Ø§Ø¦Ø± Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„: {self.simulation_results.get('estimated_insertion_loss_dB', 0):.2f} dB
           â€¢ Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„ØªØ±Ø¯Ø¯ÙŠ (3dB): {self.simulation_results.get('bandwidth_3dB_nm', 0):.1f} nm
           â€¢ Ø§Ù†Ø¹ÙƒØ§Ø³ Ø¹ÙƒØ³ÙŠ: {self.simulation_results.get('back_reflection', 0):.1%}
        
        Ù¥. Ù…ØªØ·Ù„Ø¨Ø§Øª Ø§Ù„ØªØµÙ†ÙŠØ¹:
           â€¢ Ø§Ù„Ø·Ø¨Ù‚Ø©: {self._get_layer('waveguide')} (Siâ‚ƒNâ‚„)
           â€¢ Ø³Ù…Ø§ÙƒØ©: {self.params.core_thickness} Î¼m
           â€¢ Ø¹Ù…Ù‚ Ø§Ù„ØªÙ†Ù…ÙŠØ´: {self.params.etch_depth} Î¼m
           â€¢ Ø¯Ù‚Ø© Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰: 150 nm
        
        Ù¦. Ø¥Ø±Ø´Ø§Ø¯Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:
           â€¢ Ù…Ø­Ø§Ø°Ø§Ø© Ø§Ù„Ø£Ù„ÙŠØ§Ù: Ø§Ø³ØªØ®Ø¯Ù… Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ù…Ø­Ø§Ø°Ø§Ø©
           â€¢ Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø£Ù„ÙŠØ§Ù: {self.params.angle_of_incidence}Â° Â±2Â°
           â€¢ Ù†ÙˆØ¹ Ø§Ù„Ø£Ù„ÙŠØ§Ù: SMF-28 Ø£Ùˆ Ù…Ø§ ÙŠØ¹Ø§Ø¯Ù„Ù‡Ø§
           â€¢ Ù…Ø¤Ø´Ø± Ø§Ù„Ø§Ù†ÙƒØ³Ø§Ø±: {self.params.n_cladding}
        
        ===================================================
        """
        
        return report

# ============================================================================
# Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© ÙˆØ£Ù…Ø«Ù„Ø© Ø§Ø³ØªØ®Ø¯Ø§Ù…
# ============================================================================

def create_standard_grating_coupler(wavelength_nm: float = 1550.0) -> AdvancedGratingCoupler:
    """Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø±Ù† Ù…Ø­Ø²ÙˆØ² Ù‚ÙŠØ§Ø³ÙŠ Ù„Ø·ÙˆÙ„ Ù…ÙˆØ¬ÙŠ Ù…Ø­Ø¯Ø¯."""
    params = GratingDesignParameters(
        wavelength=wavelength_nm / 1000,  # ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Î¼m
        polarization="TE",
        angle_of_incidence=10.0
    )
    
    return AdvancedGratingCoupler(params)

def create_dual_wavelength_coupler() -> gdspy.Cell:
    """Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø±Ù† Ù…Ø²Ø¯ÙˆØ¬ ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ Ø·ÙˆÙ„ÙŠÙ† Ù…ÙˆØ¬ÙŠÙŠÙ† (Ù…Ø«Ù„ 1310nm Ùˆ 1550nm)."""
    library = gdspy.GdsLibrary()
    
    # Ù…Ù‚Ø±Ù† Ù„Ù€ 1310nm
    gc_1310 = create_standard_grating_coupler(1310.0)
    cell_1310 = gc_1310.create_grating_structure((0, 0), "input")
    library.add(cell_1310)
    
    # Ù…Ù‚Ø±Ù† Ù„Ù€ 1550nm Ø¨Ø¬Ø§Ù†Ø¨Ù‡
    gc_1550 = create_standard_grating_coupler(1550.0)
    cell_1550 = gc_1550.create_grating_structure((0, 150), "input")
    library.add(cell_1550)
    
    # Ø¯Ù…Ø¬ ÙÙŠ Ø®Ù„ÙŠØ© ÙˆØ§Ø­Ø¯Ø©
    combined = gdspy.Cell("DualWavelength_GC")
    combined.add(gdspy.CellReference(cell_1310))
    combined.add(gdspy.CellReference(cell_1550))
    
    # Ø¥Ø¶Ø§ÙØ© Ù†Øµ ØªÙˆØ¶ÙŠØ­ÙŠ
    text = gdspy.Text("Dual-Î»: 1310nm & 1550nm", 10, (50, 75), layer=100)
    combined.add(text)
    
    return combined

def create_full_chip_io_array() -> gdspy.Cell:
    """Ø¥Ù†Ø´Ø§Ø¡ Ù…ØµÙÙˆÙØ© ÙƒØ§Ù…Ù„Ø© Ù„Ù…Ù†Ø§ÙØ° Ø§Ù„Ø¯Ø®Ù„/Ø®Ø±Ø¬ Ù„Ù„Ø±Ù‚Ø§Ù‚Ø©."""
    library = gdspy.GdsLibrary()
    
    # Ù…ØµÙÙˆÙØ© Ø§Ù„Ø¯Ø®Ù„ (8 Ù…Ù†Ø§ÙØ°)
    input_array_params = GratingDesignParameters()
    input_gc = AdvancedGratingCoupler(input_array_params)
    input_cell = input_gc.create_array_coupler(
        position=(0, 0),
        num_ports=8,
        spacing=127.0
    )
    library.add(input_cell)
    
    # Ù…ØµÙÙˆÙØ© Ø§Ù„Ø®Ø±Ø¬ (8 Ù…Ù†Ø§ÙØ°)
    output_array_params = GratingDesignParameters(angle_of_incidence=12.0)
    output_gc = AdvancedGratingCoupler(output_array_params)
    output_cell = output_gc.create_array_coupler(
        position=(1000, 0),
        num_ports=8,
        spacing=127.0
    )
    library.add(output_cell)
    
    # Ø®Ù„ÙŠØ© Ø±Ø¦ÙŠØ³ÙŠØ© ØªØ¬Ù…Ø¹ ÙƒÙ„ Ø´ÙŠØ¡
    main_cell = gdspy.Cell("Full_Chip_IO")
    main_cell.add(gdspy.CellReference(input_cell, (0, 0)))
    main_cell.add(gdspy.CellReference(output_cell, (1000, 0)))
    
    # Ø¥Ø¶Ø§ÙØ© Ø¥Ø·Ø§Ø± ÙˆØªØ³Ù…ÙŠØ© Ø§Ù„Ø±Ù‚Ø§Ù‚Ø©
    chip_frame = gdspy.Rectangle(
        (-100, -100),
        (1100, 1100),
        layer=0
    )
    main_cell.add(chip_frame)
    
    chip_label = gdspy.Text(
        "QUANTUM SOVEREIGN CHIP - IO ARRAY",
        20,
        (500, 1200),
        layer=100
    )
    main_cell.add(chip_label)
    
    return main_cell

# ============================================================================
# Ù…Ø«Ø§Ù„ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø¨Ø§Ø´Ø±
# ============================================================================

if __name__ == "__main__":
    print("ØªØµÙ…ÙŠÙ… Ù…Ù‚Ø±Ù† Ù…Ø­Ø²ÙˆØ² Ù„Ù„Ø±Ù‚Ø§Ù‚Ø© Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ© Ø§Ù„Ø¶ÙˆØ¦ÙŠØ©")
    print("=" * 60)
    
    # 1. Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø±Ù† Ù‚ÙŠØ§Ø³ÙŠ Ù„Ù€ 1550nm
    print("\n1. Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø±Ù† Ù‚ÙŠØ§Ø³ÙŠ @ 1550nm...")
    gc = create_standard_grating_coupler(1550.0)
    
    # 2. Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø£Ø¯Ø§Ø¡
    print("2. Ù…Ø­Ø§ÙƒØ§Ø© Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…Ù‚Ø±Ù†...")
    results = gc.simulate_performance()
    
    print(f"   â€¢ ÙƒÙØ§Ø¡Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù†: {results['coupling_efficiency']:.1%}")
    print(f"   â€¢ Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„ØªØ±Ø¯Ø¯ÙŠ: {results['bandwidth_3dB_nm']:.1f} nm")
    print(f"   â€¢ Ø®Ø³Ø§Ø¦Ø± Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„: {results['estimated_insertion_loss_dB']:.2f} dB")
    
    # 3. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ
    print("3. ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ...")
    gc_cell = gc.create_grating_structure((0, 0), "input")
    
    # 4. Ø­ÙØ¸ ÙÙŠ Ù…Ù„Ù GDS
    print("4. Ø­ÙØ¸ Ø§Ù„ØªØµÙ…ÙŠÙ… ÙÙŠ Ù…Ù„Ù...")
    lib = gdspy.GdsLibrary()
    lib.add(gc_cell)
    
    output_file = "grating_coupler_1550nm.gds"
    lib.write_gds(output_file)
    
    print(f"âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ù: {output_file}")
    
    # 5. ØªÙˆÙ„ÙŠØ¯ ØªÙ‚Ø±ÙŠØ± Ø§Ù„ØªØµÙ…ÙŠÙ…
    report = gc.generate_design_report()
    print("\n" + report)
    
    # 6. Ø­ÙØ¸ Ø§Ù„ØªÙ‚Ø±ÙŠØ±
    with open("grating_coupler_report.txt", "w", encoding="utf-8") as f:
        f.write(report)
    
    print("ğŸ“„ ØªÙ… Ø­ÙØ¸ ØªÙ‚Ø±ÙŠØ± Ø§Ù„ØªØµÙ…ÙŠÙ… ÙÙŠ: grating_coupler_report.txt")
```

ğŸš€ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªÙ†ÙÙŠØ°ÙŠØ© Ø§Ù„ÙÙˆØ±ÙŠØ©

1. Ø§Ù†Ù‚Ù„ Ø§Ù„Ù…Ù„Ù Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹:

```bash
# Ù†Ø³Ø® Ø§Ù„Ù…Ù„Ù Ø¥Ù„Ù‰ Ù…Ø¬Ù„Ø¯ Ø§Ù„Ù…ÙƒØªØ¨Ø©
cp grating_coupler.py /QUANTUM_SOVEREIGN_CHIP/03_FABRICATION/component_library/

# Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù…Ù„Ù
cd /QUANTUM_SOVEREIGN_CHIP/03_FABRICATION/component_library
python3 grating_coupler.py
```

1. ØªØ«Ø¨ÙŠØª Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ÙŠØ§Øª Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ©:

```bash
pip install gdspy numpy
```

1. Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø³Ø±ÙŠØ¹ ÙÙŠ Ø¯ÙØªØ± Ù…Ù„Ø§Ø­Ø¸Ø§Øª:

```python
# ÙÙŠ Jupyter notebook Ø¬Ø¯ÙŠØ¯
import sys
sys.path.append('../component_library')
from grating_coupler import *

# Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø±Ù† ÙˆØªØµØ¯ÙŠØ±Ù‡
gc = create_standard_grating_coupler(1550.0)
gc_cell = gc.create_grating_structure((0, 0), "input")

# Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
print(gc.generate_design_report())
```

ğŸ“Š Ø®ØµØ§Ø¦Øµ Ù…Ù‚Ø±Ù† Ø§Ù„Ù…Ø­Ø²ÙˆØ² Ø§Ù„Ù…ØµÙ…Ù…

Ø§Ù„Ù…Ø¹Ù„Ù…Ø© Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„ÙˆØ­Ø¯Ø© Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø©
Ø§Ù„Ø·ÙˆÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ 1550 nm Ø§Ù„Ù…Ø±ÙƒØ²
Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„ØªØ±Ø¯Ø¯ÙŠ ~40 nm @ 3dB
ÙƒÙØ§Ø¡Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù† ~60 % Ù…Ø¹ Ø§Ù„Ø£Ù„ÙŠØ§Ù SMF-28
Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø³Ù‚ÙˆØ· 10 Ø¯Ø±Ø¬Ø© Ø¨Ø§Ù„Ù†Ø³Ø¨Ø© Ù„Ù„Ø¹Ù…ÙˆØ¯ÙŠ
Ø®Ø³Ø§Ø¦Ø± Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ ~2.2 dB Ø´Ø§Ù…Ù„ ÙƒÙ„ Ø§Ù„Ø®Ø³Ø§Ø¦Ø±
Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø­Ø²ÙˆØ² ~0.63 Î¼m Ø­Ø³Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨
Ø¹Ø¯Ø¯ Ø§Ù„Ø¯ÙˆØ±Ø§Øª 20 - Ù„Ù„Ø·Ø§Ù‚Ø© Ø§Ù„Ù…Ø«Ù„Ù‰
Ø§Ù„Ù…Ø³Ø§Ø­Ø© 100Ã—12 Î¼mÂ² Ù„ÙƒÙ„ Ù…Ù‚Ø±Ù†

ğŸ”„ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ© 

1. Ø¯Ù…Ø¬ Ù…Ù‚Ø±Ù† Ø§Ù„Ù…Ø­Ø²ÙˆØ² ÙÙŠ Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù„Ù„Ø±Ù‚Ø§Ù‚Ø©ØŸ
Ø¯Ù…Ø¬ Ù…Ù‚Ø±Ù† Ø§Ù„Ù…Ø­Ø²ÙˆØ² ÙˆØ¥Ù†Ø´Ø§Ø¡ Ù…ØµÙÙˆÙØ© I/O ÙƒØ§Ù…Ù„Ø© Ù„Ù„Ø±Ù‚Ø§Ù‚Ø© Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ©

ğŸ—ï¸ Ù…Ù„Ù Ø§Ù„ØªÙƒØ§Ù…Ù„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù„Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„ÙƒØ§Ù…Ù„

Ù…Ù„Ù: /03_FABRICATION/layouts/integrated_design.py

```python
"""
Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„ Ù„Ù„Ø±Ù‚Ø§Ù‚Ø© Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ© Ù…Ø¹ Ù…ØµÙÙˆÙØ© I/O ÙƒØ§Ù…Ù„Ø©.
ÙŠØ¶Ù…: Ù…Ù‚Ø±Ù†Ø§Øª Ù…Ø­Ø²ÙˆØ²ØŒ Ø¯ÙˆØ§Ø¦Ø± ÙƒÙ…ÙˆÙ…ÙŠØ©ØŒ Ù…Ø³Ø§Ø±Ø§Øª Ù…ÙˆØ¬ÙŠØ©ØŒ ÙˆÙ‡ÙŠØ§ÙƒÙ„ Ø§Ø®ØªØ¨Ø§Ø±.
"""
import gdspy
import numpy as np
from typing import List, Tuple, Dict, Optional
import yaml
import json
from datetime import datetime
import sys
import os

# Ø¥Ø¶Ø§ÙØ© Ù…Ø³Ø§Ø± Ù…ÙƒØªØ¨Ø© Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª
sys.path.append('../component_library')
from grating_coupler import AdvancedGratingCoupler, GratingDesignParameters
from waveguide import QuantumWaveguide

class QuantumChipLayout:
    """Ø§Ù„ØªØ®Ø·ÙŠØ· Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„ Ù„Ù„Ø±Ù‚Ø§Ù‚Ø© Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ© Ø§Ù„Ø³ÙŠØ§Ø¯ÙŠØ©."""
    
    def __init__(self, chip_name: str = "QUANTUM_SOVEREIGN_CHIP"):
        self.chip_name = chip_name
        self.version = "1.0.0"
        self.library = gdspy.GdsLibrary()
        
        # ØªØ­Ù…ÙŠÙ„ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª PDK
        with open('../PDK/design_rules.yaml', 'r') as f:
            self.drc = yaml.safe_load(f)
        
        # ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª
        self.grating_coupler = AdvancedGratingCoupler()
        self.waveguide = QuantumWaveguide(width=0.5, layer=1)
        
        # ØªØ¹Ø±ÙŠÙ Ø·Ø¨Ù‚Ø§Øª Ø§Ù„ØªØµÙ…ÙŠÙ…
        self.layers = {
            'sin_core': 1,      # Siâ‚ƒNâ‚„ waveguides
            'algas_nonlinear': 2, # AlGaAs nonlinear elements
            'tin_heater': 10,   # TiN heaters
            'ti_via': 11,       # Ti vias
            'alignment': 0,     # Alignment marks
            'text': 100,        # Text labels
            'dicing': 200,      # Dicing streets
            'seal_ring': 201    # Seal ring
        }
        
        # Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„Ø±Ù‚Ø§Ù‚Ø©
        self.chip_width = 10000  # 10 mm
        self.chip_height = 10000 # 10 mm
        
        # Ù…ØµÙÙˆÙØ© I/O
        self.io_config = {
            'num_input_ports': 8,
            'num_output_ports': 8,
            'port_spacing': 250.0,  # Î¼m Ø¨ÙŠÙ† Ø§Ù„Ù…Ù†Ø§ÙØ°
            'array_spacing': 2000.0, # Î¼m Ø¨ÙŠÙ† Ù…ØµÙÙˆÙØªÙŠ Ø§Ù„Ø¯Ø®Ù„ ÙˆØ§Ù„Ø®Ø±Ø¬
            'edge_margin': 500.0    # Î¼m Ù…Ù† Ø­Ø§ÙØ© Ø§Ù„Ø±Ù‚Ø§Ù‚Ø©
        }
        
        # Ø¯ÙˆØ§Ø¦Ø± ÙƒÙ…ÙŠØ© Ø±Ø¦ÙŠØ³ÙŠØ©
        self.quantum_circuits = {
            'bell_state_generator': {
                'position': (4000, 5000),
                'size': (2000, 1500),
                'type': 'linear_optical'
            },
            'cnot_gate': {
                'position': (6000, 5000),
                'size': (1500, 1500),
                'type': 'nonlinear_ring'
            },
            'quantum_memory': {
                'position': (5000, 3000),
                'size': (1800, 1200),
                'type': 'resonator_array'
            }
        }
        
        # ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø®Ù„Ø§ÙŠØ§
        self.cells = {}
        self.port_positions = {}
    
    def create_full_chip_design(self) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ ØªØµÙ…ÙŠÙ… Ø§Ù„Ø±Ù‚Ø§Ù‚Ø© Ø§Ù„ÙƒØ§Ù…Ù„ Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„."""
        print("=" * 70)
        print(f"Ø¨Ø¯Ø¡ ØªØµÙ…ÙŠÙ… Ø§Ù„Ø±Ù‚Ø§Ù‚Ø© Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ©: {self.chip_name}")
        print("=" * 70)
        
        # 1. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø®Ù„ÙŠØ© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        main_cell = gdspy.Cell(self.chip_name)
        
        # 2. Ø¥Ø¶Ø§ÙØ© Ø­Ù„Ù‚Ø© Ø§Ù„Ø®ØªÙ… (Seal Ring)
        print(" 1. Ø¥Ø¶Ø§ÙØ© Ø­Ù„Ù‚Ø© Ø§Ù„Ø®ØªÙ…...")
        seal_ring = self._create_seal_ring()
        main_cell.add(seal_ring)
        
        # 3. Ø¥Ù†Ø´Ø§Ø¡ Ù…ØµÙÙˆÙØ§Øª I/O
        print(" 2. Ø¥Ù†Ø´Ø§Ø¡ Ù…ØµÙÙˆÙØ§Øª Ù…Ù†Ø§ÙØ° Ø§Ù„Ø¯Ø®Ù„/Ø®Ø±Ø¬...")
        input_array = self._create_input_array()
        output_array = self._create_output_array()
        
        main_cell.add(input_array)
        main_cell.add(output_array)
        
        # 4. Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø¨ÙƒØ© Ù…Ø³Ø§Ø±Ø§Øª Ø¯Ø§Ø®Ù„ÙŠØ©
        print(" 3. Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø¨ÙƒØ© Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ©...")
        routing_network = self._create_routing_network()
        main_cell.add(routing_network)
        
        # 5. Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¯ÙˆØ§Ø¦Ø± Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ©
        print(" 4. Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¯ÙˆØ§Ø¦Ø± Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©...")
        quantum_circuits = self._create_quantum_circuits()
        main_cell.add(quantum_circuits)
        
        # 6. Ø¥Ø¶Ø§ÙØ© Ù‡ÙŠØ§ÙƒÙ„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±
        print(" 5. Ø¥Ø¶Ø§ÙØ© Ù‡ÙŠØ§ÙƒÙ„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± ÙˆØ§Ù„ØªÙˆØµÙŠÙ...")
        test_structures = self._create_test_structures()
        main_cell.add(test_structures)
        
        # 7. Ø¥Ø¶Ø§ÙØ© Ù†ØµÙˆØµ ÙˆØªØ¹Ø±ÙŠÙØ§Øª
        print(" 6. Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†ØµÙˆØµ ÙˆØ§Ù„ØªØ¹Ø±ÙŠÙØ§Øª...")
        labels = self._create_chip_labels()
        main_cell.add(labels)
        
        # 8. Ø¥Ø¶Ø§ÙØ© Ø´ÙˆØ§Ø±Ø¹ Ø§Ù„Ù‚Ø·Ø¹ (Dicing Streets)
        print(" 7. Ø¥Ø¶Ø§ÙØ© Ø´ÙˆØ§Ø±Ø¹ Ø§Ù„Ù‚Ø·Ø¹...")
        dicing_streets = self._create_dicing_streets()
        main_cell.add(dicing_streets)
        
        print("=" * 70)
        print("âœ… ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ ØªØµÙ…ÙŠÙ… Ø§Ù„Ø±Ù‚Ø§Ù‚Ø© Ø¨Ù†Ø¬Ø§Ø­!")
        print("=" * 70)
        
        return main_cell
    
    def _create_seal_ring(self) -> gdspy.PolygonSet:
        """Ø¥Ù†Ø´Ø§Ø¡ Ø­Ù„Ù‚Ø© Ø®ØªÙ… Ø­ÙˆÙ„ Ø§Ù„Ø±Ù‚Ø§Ù‚Ø© Ù„Ø­Ù…Ø§ÙŠØªÙ‡Ø§."""
        ring_width = 100.0  # Ø¹Ø±Ø¶ Ø­Ù„Ù‚Ø© Ø§Ù„Ø®ØªÙ…
        ring_offset = 50.0  # Ø§Ù„Ù…Ø³Ø§ÙØ© Ù…Ù† Ø­Ø§ÙØ© Ø§Ù„Ø±Ù‚Ø§Ù‚Ø©
        
        # Ø§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠØ©
        outer_points = [
            (ring_offset, ring_offset),
            (self.chip_width - ring_offset, ring_offset),
            (self.chip_width - ring_offset, self.chip_height - ring_offset),
            (ring_offset, self.chip_height - ring_offset)
        ]
        
        # Ø§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ©
        inner_offset = ring_offset + ring_width
        inner_points = [
            (inner_offset, inner_offset),
            (self.chip_width - inner_offset, inner_offset),
            (self.chip_width - inner_offset, self.chip_height - inner_offset),
            (inner_offset, self.chip_height - inner_offset)
        ]
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø­Ù„Ù‚Ø© Ø§Ù„Ø®ØªÙ… (ÙØ±Ù‚ Ø¨ÙŠÙ† Ø§Ù„Ù…Ø¶Ù„Ø¹ÙŠÙ†)
        seal_ring = gdspy.boolean(
            gdspy.Polygon(outer_points),
            gdspy.Polygon(inner_points),
            'not',
            layer=self.layers['seal_ring']
        )
        
        return seal_ring
    
    def _create_input_array(self) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ Ù…ØµÙÙˆÙØ© Ù…Ù†Ø§ÙØ° Ø§Ù„Ø¯Ø®Ù„."""
        cell = gdspy.Cell("INPUT_PORTS_ARRAY")
        
        num_ports = self.io_config['num_input_ports']
        spacing = self.io_config['port_spacing']
        margin = self.io_config['edge_margin']
        
        # Ø§Ù„Ù…ÙˆØ¶Ø¹ Ø§Ù„Ø£ÙˆÙ„ÙŠ (Ø§Ù„Ø¬Ù‡Ø© Ø§Ù„ÙŠØ³Ø±Ù‰ Ù…Ù† Ø§Ù„Ø±Ù‚Ø§Ù‚Ø©)
        start_x = margin
        start_y = self.chip_height / 2 - ((num_ports - 1) * spacing) / 2
        
        # Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙ„ Ù…Ù‚Ø±Ù† Ø¯Ø®Ù„
        for i in range(num_ports):
            port_pos = (start_x, start_y + i * spacing)
            
            # Ø­ÙØ¸ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ù†ÙØ° Ù„Ù„ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠ
            self.port_positions[f'IN_{i+1}'] = {
                'position': port_pos,
                'type': 'input',
                'orientation': 'right'  # Ø§Ù„Ø¶ÙˆØ¡ ÙŠØ¯Ø®Ù„ Ø¨Ø§ØªØ¬Ø§Ù‡ Ø§Ù„ÙŠÙ…ÙŠÙ†
            }
            
            # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø±Ù† Ø§Ù„Ù…Ø­Ø²ÙˆØ² Ø§Ù„ÙØ±Ø¯ÙŠ
            gc_cell = self.grating_coupler.create_grating_structure(
                port_pos, "input"
            )
            
            # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø± Ø¯Ø§Ø®Ù„ÙŠ Ù…Ù† Ø§Ù„Ù…Ù†ÙØ°
            internal_route = self._create_internal_waveguide(
                port_pos, 
                direction='right',
                length=500.0
            )
            
            cell.add(gc_cell)
            cell.add(internal_route)
            
            # Ø¥Ø¶Ø§ÙØ© ØªØ³Ù…ÙŠØ© Ø§Ù„Ù…Ù†ÙØ°
            port_label = gdspy.Text(
                f"IN{i+1}",
                20,
                (port_pos[0] - 50, port_pos[1]),
                layer=self.layers['text']
            )
            cell.add(port_label)
            
            # Ø¥Ø¶Ø§ÙØ© Ø¹Ù„Ø§Ù…Ø© ØªØ±ØªÙŠØ¨
            order_mark = gdspy.Rectangle(
                (port_pos[0] - 10, port_pos[1] - 3),
                (port_pos[0] - 5, port_pos[1] + 3),
                layer=self.layers['alignment']
            )
            cell.add(order_mark)
        
        # Ø¥Ø¶Ø§ÙØ© Ø¥Ø·Ø§Ø± Ø­ÙˆÙ„ Ø§Ù„Ù…ØµÙÙˆÙØ©
        array_width = 200
        array_height = (num_ports - 1) * spacing + 200
        array_frame = gdspy.Rectangle(
            (start_x - 100, start_y - 100),
            (start_x + array_width, start_y + array_height - 100),
            layer=self.layers['alignment']
        )
        cell.add(array_frame)
        
        return cell
    
    def _create_output_array(self) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ Ù…ØµÙÙˆÙØ© Ù…Ù†Ø§ÙØ° Ø§Ù„Ø®Ø±Ø¬."""
        cell = gdspy.Cell("OUTPUT_PORTS_ARRAY")
        
        num_ports = self.io_config['num_output_ports']
        spacing = self.io_config['port_spacing']
        margin = self.io_config['edge_margin']
        
        # Ø§Ù„Ù…ÙˆØ¶Ø¹ Ø§Ù„Ø£ÙˆÙ„ÙŠ (Ø§Ù„Ø¬Ù‡Ø© Ø§Ù„ÙŠÙ…Ù†Ù‰ Ù…Ù† Ø§Ù„Ø±Ù‚Ø§Ù‚Ø©)
        start_x = self.chip_width - margin
        start_y = self.chip_height / 2 - ((num_ports - 1) * spacing) / 2
        
        # Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙ„ Ù…Ù‚Ø±Ù† Ø®Ø±Ø¬
        for i in range(num_ports):
            port_pos = (start_x, start_y + i * spacing)
            
            # Ø­ÙØ¸ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ù†ÙØ°
            self.port_positions[f'OUT_{i+1}'] = {
                'position': port_pos,
                'type': 'output',
                'orientation': 'left'  # Ø§Ù„Ø¶ÙˆØ¡ ÙŠØ®Ø±Ø¬ Ø¨Ø§ØªØ¬Ø§Ù‡ Ø§Ù„ÙŠØ³Ø§Ø±
            }
            
            # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø±Ù† Ø§Ù„Ù…Ø­Ø²ÙˆØ² Ø§Ù„ÙØ±Ø¯ÙŠ
            gc_cell = self.grating_coupler.create_grating_structure(
                port_pos, "output"
            )
            
            # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø± Ø¯Ø§Ø®Ù„ÙŠ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ù†ÙØ°
            internal_route = self._create_internal_waveguide(
                port_pos, 
                direction='left',
                length=500.0
            )
            
            cell.add(gc_cell)
            cell.add(internal_route)
            
            # Ø¥Ø¶Ø§ÙØ© ØªØ³Ù…ÙŠØ© Ø§Ù„Ù…Ù†ÙØ°
            port_label = gdspy.Text(
                f"OUT{i+1}",
                20,
                (port_pos[0] + 50, port_pos[1]),
                layer=self.layers['text']
            )
            cell.add(port_label)
            
            # Ø¥Ø¶Ø§ÙØ© Ø¹Ù„Ø§Ù…Ø© ØªØ±ØªÙŠØ¨
            order_mark = gdspy.Rectangle(
                (port_pos[0] + 5, port_pos[1] - 3),
                (port_pos[0] + 10, port_pos[1] + 3),
                layer=self.layers['alignment']
            )
            cell.add(order_mark)
        
        return cell
    
    def _create_internal_waveguide(self, start_pos: Tuple[float, float],
                                  direction: str, length: float) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø± Ù…ÙˆØ¬Ù‡ Ø¯Ø§Ø®Ù„ÙŠ Ù…Ù†/Ø¥Ù„Ù‰ Ø§Ù„Ù…Ù†ÙØ°."""
        cell = gdspy.Cell(f"Waveguide_Internal")
        
        # ØªØ­Ø¯ÙŠØ¯ Ù†Ù‚Ø·Ø© Ø§Ù„Ù†Ù‡Ø§ÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø§ØªØ¬Ø§Ù‡
        if direction == 'right':
            end_pos = (start_pos[0] + length, start_pos[1])
        elif direction == 'left':
            end_pos = (start_pos[0] - length, start_pos[1])
        else:
            end_pos = (start_pos[0], start_pos[1] + length)
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø± Ù…Ø³ØªÙ‚ÙŠÙ… Ø£ÙˆÙ„ÙŠ
        waveguide = self.waveguide.create_straight(start_pos, end_pos)
        cell.add(waveguide)
        
        # Ø¥Ø¶Ø§ÙØ© Ù…Ù†Ø¹Ø·ÙØ§Øª Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø± Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªØ¯Ø§Ø®Ù„
        if abs(end_pos[1] - start_pos[1]) < 100:
            # Ù…Ø³Ø§Ø± Ø¨Ø³ÙŠØ· Ù…Ø³ØªÙ‚ÙŠÙ…
            pass
        else:
            # Ù…Ø³Ø§Ø± Ù…Ø¹ Ù…Ù†Ø¹Ø·ÙØ§Øª
            cell = self._create_routed_waveguide(start_pos, end_pos)
        
        return cell
    
    def _create_routed_waveguide(self, start: Tuple[float, float],
                                end: Tuple[float, float]) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø± Ù…ÙˆØ¬Ù‡ Ù…Ø¹ Ù…Ù†Ø¹Ø·ÙØ§Øª Ù„Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ø¯ÙˆØ§Ø¦Ø± Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ©."""
        cell = gdspy.Cell(f"Routed_WG_{start[0]:.0f}_{start[1]:.0f}")
        
        x1, y1 = start
        x2, y2 = end
        
        # ØªØµÙ…ÙŠÙ… Ù…Ø³Ø§Ø± Ø¹Ù„Ù‰ Ø´ÙƒÙ„ "Ù…Ø§Ù†Ù‡Ø§ØªÙ†" (Manhattan routing)
        bend_radius = 50.0  # Ù†ØµÙ Ù‚Ø·Ø± Ø§Ù„Ø§Ù†Ø­Ù†Ø§Ø¡
        
        # Ù†Ù‚Ø·Ø© ÙˆØ³ÙŠØ·Ø© Ø£ÙÙ‚ÙŠØ©
        mid_x = (x1 + x2) / 2
        
        # Ø§Ù„Ù…Ø³Ø§Ø±: Ø¨Ø¯Ø§ÙŠØ© â†’ Ù…Ù†Ø¹Ø·Ù â†’ Ø¬Ø²Ø¡ Ø±Ø£Ø³ÙŠ â†’ Ù…Ù†Ø¹Ø·Ù â†’ Ù†Ù‡Ø§ÙŠØ©
        points = [
            (x1, y1),  # Ø¨Ø¯Ø§ÙŠØ©
            (x1 + bend_radius, y1),  # Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ù…Ù†Ø¹Ø·Ù
            (x1 + bend_radius, y2),  # Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø±Ø£Ø³ÙŠ
            (x2 - bend_radius, y2),  # Ù‚Ø¨Ù„ Ø§Ù„Ù…Ù†Ø¹Ø·Ù Ø§Ù„Ø£Ø®ÙŠØ±
            (x2, y2)  # Ù†Ù‡Ø§ÙŠØ©
        ]
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³Ø§Ø± Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… FlexPath
        path = gdspy.FlexPath(
            points,
            width=0.5,
            corners="circular",
            bend_radius=bend_radius,
            layer=self.layers['sin_core'],
            gdsii_path=True
        )
        
        cell.add(path)
        
        return cell
    
    def _create_routing_network(self) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø¨ÙƒØ© ØªÙˆØ¬ÙŠÙ‡ ÙƒØ§Ù…Ù„Ø© ØªØ±Ø¨Ø· Ø§Ù„Ù…Ù†Ø§ÙØ° Ø¨Ø§Ù„Ø¯ÙˆØ§Ø¦Ø±."""
        cell = gdspy.Cell("ROUTING_NETWORK")
        
        print("    â€¢ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø±Ø§Øª Ù…Ù† Ø§Ù„Ù…Ø¯Ø§Ø®Ù„ Ø¥Ù„Ù‰ Ø¯ÙˆØ§Ø¦Ø± Bell State...")
        # ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„Ù…Ø¯Ø§Ø®Ù„ 1-4 Ø¥Ù„Ù‰ Ø¯Ø§Ø¦Ø±Ø© ØªÙˆÙ„ÙŠØ¯ Bell State
        bell_circuit_pos = self.quantum_circuits['bell_state_generator']['position']
        
        for i in range(4):
            if f'IN_{i+1}' in self.port_positions:
                port_info = self.port_positions[f'IN_{i+1}']
                start_pos = (port_info['position'][0] + 500, port_info['position'][1])
                
                # Ø§Ù„Ù†Ù‡Ø§ÙŠØ© Ø¹Ù†Ø¯ Ø§Ù„Ø¯Ø§Ø¦Ø±Ø© Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ©
                end_pos = (
                    bell_circuit_pos[0] - 200,
                    bell_circuit_pos[1] - 300 + i * 150
                )
                
                route = self._create_smart_route(start_pos, end_pos, f"Route_IN{i+1}_Bell")
                cell.add(route)
        
        print("    â€¢ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø±Ø§Øª Ù…Ù† Bell State Ø¥Ù„Ù‰ Ø¨ÙˆØ§Ø¨Ø© CNOT...")
        # ØªÙˆØ¬ÙŠÙ‡ Ù…Ù† Bell State Ø¥Ù„Ù‰ CNOT
        cnot_pos = self.quantum_circuits['cnot_gate']['position']
        
        for i in range(2):  # Ù‚Ù†Ø§ØªØ§Ù† Ù…ØªØ´Ø§Ø¨ÙƒØªØ§Ù†
            start_pos = (
                bell_circuit_pos[0] + 1000,
                bell_circuit_pos[1] - 200 + i * 400
            )
            end_pos = (
                cnot_pos[0] - 200,
                cnot_pos[1] - 100 + i * 200
            )
            
            route = self._create_smart_route(start_pos, end_pos, f"Route_Bell_CNOT_{i+1}")
            cell.add(route)
        
        print("    â€¢ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø±Ø§Øª Ù…Ù† CNOT Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø®Ø§Ø±Ø¬...")
        # ØªÙˆØ¬ÙŠÙ‡ Ù…Ù† CNOT Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø®Ø§Ø±Ø¬
        for i in range(4):
            if f'OUT_{i+1}' in self.port_positions:
                port_info = self.port_positions[f'OUT_{i+1}']
                end_pos = (port_info['position'][0] - 500, port_info['position'][1])
 Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ©
                start_pos = (
                    cnot_pos[0] + 800,
                    cnot_pos[1] - 300 + i * 200
                )
                
                route = self._create_smart_route(start_pos, end_pos, f"Route_CNOT_OUT{i+1}")
                cell.add(route)
        
        return cell
    
    def _create_smart_route(self, start: Tuple[float, float], 
                           end: Tuple[float, float],
                           route_name: str) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø± Ø°ÙƒÙŠ Ù…Ø¹ ØªØ¬Ù†Ø¨ Ø§Ù„Ø¹ÙˆØ§Ø¦Ù‚."""
        cell = gdspy.Cell(route_name)
        
        x1, y1 = start
        x2, y2 = end
        
        # ØªØ­Ø¯ÙŠØ¯ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³Ø§Ø± ÙŠØªØ·Ù„Ø¨ Ù…Ù†Ø¹Ø·ÙØ§Øª ÙƒØ«ÙŠØ±Ø©
        horizontal_distance = abs(x2 - x1)
        vertical_distance = abs(y2 - y1)
        
        # Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„Ø£ÙÙ‚ÙŠØ© ÙƒØ¨ÙŠØ±Ø©ØŒ Ø§Ø³ØªØ®Ø¯Ù… Ù…Ø³Ø§Ø±Ù‹Ø§ Ù…Ø¹ Ù…Ù†Ø¹Ø·ÙØ§Øª
        if horizontal_distance > 1000:
            # Ù…Ø³Ø§Ø± Ø¨Ù…Ù†Ø¹Ø·ÙÙŠÙ† (Ø¨Ø¯ÙŠÙ„)
            mid_y = (y1 + y2) / 2
            
            points = [
                (x1, y1),
                (x1 + 200, y1),      # Ø¬Ø²Ø¡ Ø£ÙÙ‚ÙŠ
                (x1 + 200, mid_y),   # Ø¬Ø²Ø¡ Ø±Ø£Ø³ÙŠ
                (x2 - 200, mid_y),   # Ø¬Ø²Ø¡ Ø£ÙÙ‚ÙŠ
                (x2 - 200, y2),      # Ø¬Ø²Ø¡ Ø±Ø£Ø³ÙŠ
                (x2, y2)             # Ù†Ù‡Ø§ÙŠØ©
            ]
        else:
            # Ù…Ø³Ø§Ø± Ù…Ø¨Ø§Ø´Ø± Ø£ÙƒØ«Ø±
            points = [start, end]
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³Ø§Ø±
        path = gdspy.FlexPath(
            points,
            width=0.5,
            corners="circular",
            bend_radius=25.0,
            layer=self.layers['sin_core'],
            gdsii_path=True
        )
        
        cell.add(path)
        
        # Ø¥Ø¶Ø§ÙØ© Ù…Ù‚Ø³Ù… Ø´Ø¹Ø§Ø¹ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³Ø§Ø± ÙŠØªÙØ±Ø¹
        if 'Bell' in route_name and 'IN' in route_name:
            splitter = self._create_beam_splitter(
                (points[2][0] - 50, points[2][1]),
                coupling=0.5
            )
            cell.add(splitter)
        
        return cell
    
    def _create_beam_splitter(self, position: Tuple[float, float],
                             coupling: float = 0.5) -> gdspy.PolygonSet:
        """Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø³Ù… Ø´Ø¹Ø§Ø¹ Ø¨Ø³ÙŠØ·."""
        # ØªØµÙ…ÙŠÙ… Ù…Ø¨Ø³Ø· Ù„Ù…Ù‚Ø³Ù… Ø´Ø¹Ø§Ø¹
        length = 20.0
        width = 0.5
        gap = 0.15
        
        x, y = position
        
        # Ø¯Ù„ÙŠÙ„ÙŠÙ† Ù…ÙˆØ¬ÙŠÙŠÙ† Ù…ØªÙˆØ§Ø²ÙŠÙŠÙ† Ù…Ø¹ Ø§Ù‚ØªØ±Ø§Ù†
        wg1 = gdspy.Rectangle(
            (x, y - gap/2 - width),
            (x + length, y - gap/2),
            layer=self.layers['sin_core']
        )
        
        wg2 = gdspy.Rectangle(
            (x, y + gap/2),
            (x + length, y + gap/2 + width),
            layer=self.layers['sin_core']
        )
        
        # Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù†
        coupling_region = gdspy.Rectangle(
            (x + length/2 - 2, y - gap/2 - width),
            (x + length/2 + 2, y + gap/2 + width),
            layer=self.layers['sin_core']
        )
        
        return wg1, wg2, coupling_region
    
    def _create_quantum_circuits(self) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯ÙˆØ§Ø¦Ø± Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©."""
        cell = gdspy.Cell("QUANTUM_CIRCUITS")
        
        # 1. Ø¯Ø§Ø¦Ø±Ø© ØªÙˆÙ„ÙŠØ¯ Ø­Ø§Ù„Ø© Bell
        bell_circuit = self._create_bell_state_circuit(
            self.quantum_circuits['bell_state_generator']['position']
        )
        cell.add(bell_circuit)
        
        # 2. Ø¨ÙˆØ§Ø¨Ø© CNOT ØºÙŠØ± Ø®Ø·ÙŠØ©
        cnot_circuit = self._create_cnot_gate(
            self.quantum_circuits['cnot_gate']['position']
        )
        cell.add(cnot_circuit)
        
        # 3. Ø°Ø§ÙƒØ±Ø© ÙƒÙ…ÙˆÙ…ÙŠØ© (Ù…ØµÙÙˆÙØ© Ø±Ù†Ø§Ù†Ø§Øª)
        memory_circuit = self._create_quantum_memory(
            self.quantum_circuits['quantum_memory']['position']
        )
        cell.add(memory_circuit)
        
        return cell
    
    def _create_bell_state_circuit(self, position: Tuple[float, float]) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ Ø¯Ø§Ø¦Ø±Ø© ØªÙˆÙ„ÙŠØ¯ Ø­Ø§Ù„Ø© Bell Ù…ØªØ´Ø§Ø¨ÙƒØ©."""
        cell = gdspy.Cell("BELL_STATE_GENERATOR")
        
        x, y = position
        
        # Ø¥Ø·Ø§Ø± Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©
        frame = gdspy.Rectangle(
            (x - 1000, y - 750),
            (x + 1000, y + 750),
            layer=self.layers['alignment']
        )
        cell.add(frame)
        
        # Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©
        title = gdspy.Text(
            "BELL STATE GENERATOR",
            30,
            (x, y + 800),
            layer=self.layers['text']
        )
        cell.add(title)
        
        # Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ø¯Ø§Ø¦Ø±Ø© Ø§Ù„Ø¨ØµØ±ÙŠØ©
        # 1. Ù…Ù‚Ø³Ù… Ø´Ø¹Ø§Ø¹ 50:50 Ù…Ø±ÙƒØ²ÙŠ
        bs = gdspy.Rectangle(
            (x - 10, y - 100),
            (x + 10, y + 100),
            layer=self.layers['sin_core']
        )
        cell.add(bs)
        
        bs_label = gdspy.Text("BS 50:50", 15, (x, y + 120), layer=self.layers['text'])
        cell.add(bs_label)
        
        # 2. Ù…Ø³Ø®Ù†ÙŠ Ø·ÙˆØ± Ù‚Ø§Ø¨Ù„ÙŠÙ† Ù„Ù„Ø¶Ø¨Ø·
        for i, y_offset in enumerate([-200, 200]):
            phase_shifter = gdspy.Rectangle(
                (x + 200, y + y_offset - 25),
                (x + 400, y + y_offset + 25),
                layer=self.layers['tin_heater']
            )
            cell.add(phase_shifter)
            
            # Ù†Ù‚Ø§Ø· Ø§ØªØµØ§Ù„ ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠØ©
            for x_contact in [x + 180, x + 420]:
                contact = gdspy.Rectangle(
                    (x_contact, y + y_offset - 15),
                    (x_contact + 20, y + y_offset + 15),
                    layer=self.layers['ti_via']
                )
                cell.add(contact)
            
            ps_label = gdspy.Text(f"PS{i+1}", 12, (x + 300, y + y_offset + 50), 
                                 layer=self.layers['text'])
            cell.add(ps_label)
        
        # 3. Ù…Ø³Ø§Ø±Ø§Øª Ø¯Ø§Ø®Ù„ÙŠØ©
        # Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ù…Ù† Ø§Ù„Ù…Ø¯Ø§Ø®Ù„ Ø¥Ù„Ù‰ Ù…Ù‚Ø³Ù… Ø§Ù„Ø´Ø¹Ø§Ø¹
for y_in in [-300, -100, 100, 300]:
            waveguide = gdspy.FlexPath(
                [(x - 500, y + y_in), (x - 10, y + y_in/3)],
                width=0.5,
                layer=self.layers['sin_core']
            )
            cell.add(waveguide)
        
        # Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ù…Ù† Ù…Ù‚Ø³Ù… Ø§Ù„Ø´Ø¹Ø§Ø¹ Ø¥Ù„Ù‰ Ù…Ø³Ø®Ù†ÙŠ Ø§Ù„Ø·ÙˆØ±
        for y_out in [-200, 200]:
            waveguide = gdspy.FlexPath(
                [(x + 10, y_out/3), (x + 200, y + y_out)],
                width=0.5,
                layer=self.layers['sin_core']
            )
            cell.add(waveguide)
        
        # 4. Ù…Ù†Ø·Ù‚Ø© Ø§Ù„ØªØ¯Ø§Ø®Ù„
        interference_zone = gdspy.Rectangle(
            (x + 450, y - 300),
            (x + 650, y + 300),
            layer=self.layers['sin_core']
        )
        cell.add(interference_zone)
        
        zone_label = gdspy.Text("Interference", 15, (x + 550, y - 350), 
                               layer=self.layers['text'])
        cell.add(zone_label)
        
        # 5. Ù…Ø®Ø§Ø±Ø¬ Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©
        for i, y_out in enumerate([-250, -150, 150, 250]):
            waveguide = gdspy.FlexPath(
                [(x + 650, y + y_out), (x + 800, y + y_out)],
                width=0.5,
                layer=self.layers['sin_core']
            )
            cell.add(waveguide)
            
            out_label = gdspy.Text(f"Out{i+1}", 12, (x + 850, y + y_out), 
                                  layer=self.layers['text'])
            cell.add(out_label)
        
        return cell
    
    def _create_cnot_gate(self, position: Tuple[float, float]) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ Ø¨ÙˆØ§Ø¨Ø© CNOT Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø­Ù„Ù‚Ø§Øª Ø±Ù†Ø§Ù†Ø© ØºÙŠØ± Ø®Ø·ÙŠØ©."""
        cell = gdspy.Cell("CNOT_QUANTUM_GATE")
        
        x, y = position
        
        # Ø¥Ø·Ø§Ø± Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©
        frame = gdspy.Rectangle(
            (x - 750, y - 750),
            (x + 750, y + 750),
            layer=self.layers['alignment']
        )
        cell.add(frame)
        
        # Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©
        title = gdspy.Text(
            "CNOT QUANTUM GATE",
            30,
            (x, y + 800),
            layer=self.layers['text']
        )
        cell.add(title)
        
        # 1. Ø­Ù„Ù‚Ø§Øª Ø±Ù†Ø§Ù†Ø© ØºÙŠØ± Ø®Ø·ÙŠØ© (AlGaAs)
        for i, y_ring in enumerate([-200, 200]):
            # Ø§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ù†Ø§Ù†Ø©
            ring_radius = 50.0
            ring = gdspy.Round(
                (x, y + y_ring),
                ring_radius,
                inner_radius=ring_radius - 0.5,
                layer=self.layers['algas_nonlinear']
            )
            cell.add(ring)
            
            # Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø­Ø§ÙÙ„Ø© (Bus Waveguide)
            bus_y = y + y_ring + ring_radius + 0.2
            bus = gdspy.Rectangle(
                (x - ring_radius - 20, bus_y - 0.25),
                (x + ring_radius + 20, bus_y + 0.25),
                layer=self.layers['sin_core']
            )
            cell.add(bus)
            
            ring_label = gdspy.Text(f"Kerr Ring {i+1}", 15, (x, y + y_ring - 80), 
                                   layer=self.layers['text'])
            cell.add(ring_label)
        
        # 2. Ù…Ø³Ø®Ù†Ø§Øª Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ø­Ù„Ù‚Ø§Øª
        for i, y_heater in enumerate([-200, 200]):
            heater = gdspy.Rectangle(
                (x - 40, y + y_heater - 80),
                (x + 40, y + y_heater - 60),
                layer=self.layers['tin_heater']
            )
            cell.add(heater)
            
            # Ø§ØªØµØ§Ù„Ø§Øª ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠØ©
            for x_contact in [x - 50, x + 30]:
                contact = gdspy.Rectangle(
                    (x_contact, y + y_heater - 85),
                    (x_contact + 20, y + y_heater - 55),
                    layer=self.layers['ti_via']
                )
                cell.add(contact)
        
        # 3. Ù…Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¨ÙˆØ§Ø¨Ø©
        input_labels = ["Control", "Target"]
        for i, y_in in enumerate([-200, 200]):
            waveguide = gdspy.FlexPath(
                [(x - 600, y + y_in), (x - 70, y + y_in)],
                width=0.5,
                layer=self.layers['sin_core']
            )
            cell.add(waveguide)
            
            in_label = gdspy.Text(f"{input_labels[i]} In", 15, 
                                 (x - 650, y + y_in), layer=self.layers['text'])
            cell.add(in_label)
        
        # 4. Ù…Ø®Ø§Ø±Ø¬ Ø§Ù„Ø¨ÙˆØ§Ø¨Ø©
        for i, y_out in enumerate([-200, 200]):
            waveguide = gdspy.FlexPath(
                [(x + 70, y + y_out), (x + 600, y + y_out)],
                width=0.5,
                layer=self.layers['sin_core']
            )
            cell.add(waveguide)
            
            out_label = gdspy.Text(f"Out{i+1}", 15, (x + 650, y + y_out), 
                                  layer=self.layers['text'])
        cell.add(out_label)
        
        # 5. Ù…Ù†Ø·Ù‚Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ
        control_zone = gdspy.Rectangle(
            (x - 100, y - 300),
            (x + 100, y - 200),
            layer=self.layers['tin_heater']
        )
        cell.add(control_zone)
        
        ctrl_label = gdspy.Text("Control Electronics", 12, (x, y - 350), 
                               layer=self.layers['text'])
        cell.add(ctrl_label)
        
        return cell
    
    def _create_quantum_memory(self, position: Tuple[float, float]) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ Ø°Ø§ÙƒØ±Ø© ÙƒÙ…ÙˆÙ…ÙŠØ© (Ù…ØµÙÙˆÙØ© Ø±Ù†Ø§Ù†Ø§Øª)."""
        cell = gdspy.Cell("QUANTUM_MEMORY")
        
        x, y = position
        
        # Ø¥Ø·Ø§Ø± Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©
        frame = gdspy.Rectangle(
            (x - 900, y - 600),
            (x + 900, y + 600),
            layer=self.layers['alignment']
        )
        cell.add(frame)
        
        # Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©
        title = gdspy.Text(
            "QUANTUM MEMORY (Resonator Array)",
            25,
            (x, y + 650),
            layer=self.layers['text']
        )
        cell.add(title)
        
        # Ù…ØµÙÙˆÙØ© Ù…Ù† Ø§Ù„Ø­Ù„Ù‚Ø§Øª Ø§Ù„Ø±Ù†Ø§Ù†Ø©
        num_rows = 4
        num_cols = 4
        ring_spacing = 200
        
        for row in range(num_rows):
            for col in range(num_cols):
                ring_x = x - (num_cols-1) * ring_spacing / 2 + col * ring_spacing
                ring_y = y - (num_rows-1) * ring_spacing / 2 + row * ring_spacing
                
                # Ø­Ù„Ù‚Ø© Ø±Ù†Ø§Ù†Ø© ØµØºÙŠØ±Ø©
                ring = gdspy.Round(
                    (ring_x, ring_y),
                    20.0,
                    inner_radius=19.5,
                    layer=self.layers['sin_core']
                )
                cell.add(ring)
                
                # Ø¯Ù„ÙŠÙ„ Ø§Ù‚ØªØ±Ø§Ù†
                coupler = gdspy.Rectangle(
                    (ring_x - 30, ring_y + 25),
                    (ring_x + 30, ring_y + 27),
                    layer=self.layers['sin_core']
                )
                cell.add(coupler)
                
                # Ù…Ø³Ø®Ù† ØªØ­ÙƒÙ… ÙØ±Ø¯ÙŠ
                heater = gdspy.Rectangle(
                    (ring_x - 15, ring_y - 40),
                    (ring_x + 15, ring_y - 35),
                    layer=self.layers['tin_heater']
                )
                cell.add(heater)
        
        # Ø¯Ù„ÙŠÙ„ Ù…ÙˆØ¬Ù‡ Ø±Ø¦ÙŠØ³ÙŠ Ù„Ù„ØªØºØ°ÙŠØ©
        main_bus = gdspy.FlexPath(
            [(x - 950, y), (x + 950, y)],
            width=0.5,
            layer=self.layers['sin_core']
        )
        cell.add(main_bus)
        
        bus_label = gdspy.Text("Main Bus Waveguide", 15, (x, y - 100), 
                              layer=self.layers['text'])
        cell.add(bus_label)
        
        return cell
    
    def _create_test_structures(self) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ Ù‡ÙŠØ§ÙƒÙ„ Ø§Ø®ØªØ¨Ø§Ø± ÙˆØªÙˆØµÙŠÙ."""
        cell = gdspy.Cell("TEST_STRUCTURES")
        
        # ÙˆØ¶Ø¹ Ù‡ÙŠØ§ÙƒÙ„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± ÙÙŠ Ø§Ù„Ø²ÙˆØ§ÙŠØ§
        corners = [
            (500, 500),           # Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„ÙŠØ³Ø±Ù‰ Ø§Ù„Ø³ÙÙ„Ù‰
            (self.chip_width - 500, 500),  # Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„ÙŠÙ…Ù†Ù‰ Ø§Ù„Ø³ÙÙ„Ù‰
            (500, self.chip_height - 500), # Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„ÙŠØ³Ø±Ù‰ Ø§Ù„Ø¹Ù„ÙŠØ§
            (self.chip_width - 500, self.chip_height - 500) # Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„ÙŠÙ…Ù†Ù‰ Ø§Ù„Ø¹Ù„ÙŠØ§
        ]
        
        for i, corner in enumerate(corners):
            test_cell = self._create_test_structure_set(corner, f"TestSet_{i+1}")
            cell.add(test_cell)
        
        return cell
    
    def _create_test_structure_set(self, position: Tuple[float, float], 
                                  set_name: str) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù…ÙˆØ¹Ø© Ù‡ÙŠØ§ÙƒÙ„ Ø§Ø®ØªØ¨Ø§Ø± ÙÙŠ Ù…ÙˆÙ‚Ø¹ Ù…Ø¹ÙŠÙ†."""
        cell = gdspy.Cell(set_name)
        
        x, y = position
        
        # 1. Ù‡ÙŠØ§ÙƒÙ„ Ù‚ÙŠØ§Ø³ Ø§Ù„Ø®Ø³Ø§Ø¦Ø±
        for i, length in enumerate([1000, 5000, 10000]):
            wg = gdspy.Rectangle(
                (x, y + i * 150),
                (x + length, y + i * 150 + 0.5),
                layer=self.layers['sin_core']
            )
            cell.add(wg)
            
            length_label = gdspy.Text(f"L={length}Î¼m", 10, 
                                     (x + length/2, y + i * 150 - 20),
                                     layer=self.layers['text'])
            cell.add(length_label)
        
        # 2. Ù…Ù‚Ø³Ù…Ø§Øª Ø£Ø´Ø¹Ø© Ø¨Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù‚ØªØ±Ø§Ù† Ù…Ø®ØªÙ„ÙØ©
        x_offset = x + 200
        for i, coupling in enumerate([0.1, 0.3, 0.5, 0.7, 0.9]):
            # ØªØµÙ…ÙŠÙ… Ù…Ø¨Ø³Ø· Ù„Ù…Ù‚Ø³Ù… Ø´Ø¹Ø§Ø¹
            coupler = gdspy.Rectangle(
                (x_offset + i * 100, y),
                (x_offset + i * 100 + 20, y + 50),
                layer=self.layers['sin_core']
            )
            cell.add(coupler)
            
            coupling_label = gdspy.Text(f"Îº={coupling}", 8,
                                       (x_offset + i * 100 + 10, y - 15),
                                       layer=self.layers['text'])
            cell.add(coupling_label)
        
        # 3. Ø­Ù„Ù‚Ø§Øª Ø±Ù†Ø§Ù†Ø© Ø¨Ø£Ø­Ø¬Ø§Ù… Ù…Ø®ØªÙ„ÙØ©
        x_rings = x + 800
        for i, radius in enumerate([20, 40, 60, 80]):
            ring = gdspy.Round(
                (x_rings + i * 120, y + 100),
                radius,
                inner_radius=radius - 0.5,
                layer=self.layers['sin_core']
            )
            cell.add(ring)
            
            radius_label = gdspy.Text(f"R={radius}", 8,
                                     (x_rings + i * 120, y + 100 + radius + 20),
                                     layer=self.layers['text'])
            cell.add(radius_label)
        
        # 4. Ù‡ÙŠØ§ÙƒÙ„ Ù…Ø­Ø§Ø°Ø§Ø© Ø¨ØµØ±ÙŠØ©
        alignment = self._create_alignment_pattern((x + 400, y + 300))
        cell.add(alignment)
        
        # 5. Ù‡ÙŠØ§ÙƒÙ„ Ù‚ÙŠØ§Ø³ ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠØ©
        for i in range(4):
            resistor = gdspy.Rectangle(
                (x + 50 + i * 80, y + 400),
                (x + 100 + i * 80, y + 410),
                layer=self.layers['tin_heater']
            )
            cell.add(resistor)
            
            # Ù†Ù‚Ø§Ø· Ø§ØªØµØ§Ù„
            for j in range(2):
                contact = gdspy.Rectangle(
                    (x + 50 + i * 80 + j * 40, y + 395),
                    (x + 70 + i * 80 + j * 40, y + 415),
                    layer=self.layers['ti_via']
                )
                cell.add(contact)
        
        return cell
    
    def _create_alignment_pattern(self, position: Tuple[float, float]) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ Ù†Ù…Ø· Ù…Ø­Ø§Ø°Ø§Ø© Ø¨ØµØ±ÙŠØ©."""
        cell = gdspy.Cell("Alignment_Pattern")
        
        x, y = position
        
        # ØµÙ„ÙŠØ¨ Ù…Ø±ÙƒØ²ÙŠ
        cross_size = 50
        # Ø®Ø· Ø£ÙÙ‚ÙŠ
        h_line = gdspy.Rectangle(
            (x - cross_size/2, y - 1),
            (x + cross_size/2, y + 1),
            layer=self.layers['alignment']
        )
        # Ø®Ø· Ø±Ø£Ø³ÙŠ
        v_line = gdspy.Rectangle(
            (x - 1, y - cross_size/2),
            (x + 1, y + cross_size/2),
            layer=self.layers['alignment']
        )
        
        # Ø¯ÙˆØ§Ø¦Ø± Ù…ØªØ­Ø¯Ø© Ø§Ù„Ù…Ø±ÙƒØ²
        for radius in [10, 20, 30, 40]:
            circle = gdspy.Round(
                (x, y),
                radius,
                layer=self.layers['alignment']
            )
            cell.add(circle)
        
        cell.add(h_line)
        cell.add(v_line)
        
        return cell
    
    def _create_chip_labels(self) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù†ØµÙˆØµ ÙˆØ§Ù„ØªØ¹Ø±ÙŠÙØ§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø±Ù‚Ø§Ù‚Ø©."""
        cell = gdspy.Cell("CHIP_LABELS")
        
        # Ø§Ù„Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
        main_title = gdspy.Text(
            f"{self.chip_name} v{self.version}",
            100,
            (self.chip_width/2, self.chip_height - 200),
            layer=self.layers['text']
        )
        cell.add(main_title)
        
        # ÙˆØµÙ Ø§Ù„Ø±Ù‚Ø§Ù‚Ø©
        description = gdspy.Text(
            "QUANTUM PHOTONIC SOVEREIGN CHIP",
            50,
            (self.chip_width/2, self.chip_height - 300),
            layer=self.layers['text']
        )
        cell.add(description)
        
        # Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªØµÙ…ÙŠÙ…
        info_lines = [
            "Hybrid Siâ‚ƒNâ‚„/AlGaAs Quantum Photonic Circuit",
            f"Design Date: {datetime.now().strftime('%Y-%m-%d')}",
            "Features: Bell State Generation, CNOT Gate, Quantum Memory",
            "I/O: 8 Input Ports, 8 Output Ports @ 1550nm",
            "Technology: 220nm Siâ‚ƒNâ‚„ + 300nm AlGaAs"
        ]
        
        for i, line in enumerate(info_lines):
            text = gdspy.Text(
                line,
                25,
                (self.chip_width/2, self.chip_height - 450 - i * 40),
                layer=self.layers['text']
            )
            cell.add(text)
        
        # ØªØ³Ù…ÙŠØ© Ø§Ù„Ù…Ù†Ø§Ø·Ù‚
        regions = [
            ("INPUT PORTS", (500, self.chip_height/2)),
            ("BELL STATE GENERATOR", (4000, 6500)),
            ("CNOT QUANTUM GATE", (6000, 6500)),
            ("QUANTUM MEMORY", (5000, 3500)),
            ("OUTPUT PORTS", (9500, self.chip_height/2)),
            ("TEST STRUCTURES", "corners")
        ]
        
        for label, pos in regions:
            if pos == "corners":
                # ÙˆØ¶Ø¹ ÙÙŠ Ø§Ù„Ø²ÙˆØ§ÙŠØ§
                corners = [
                    (1000, 1000),
                    (self.chip_width - 1000, 1000),
                    (1000, self.chip_height - 1000),
                    (self.chip_width - 1000, self.chip_height - 1000)
                ]
                for corner in corners:
                    region_text = gdspy.Text(
                        "TEST",
                        30,
                        corner,
                        layer=self.layers['text']
                    )
                    cell.add(region_text)
            else:
                region_text = gdspy.Text(
                    label,
                    35,
                    pos,
                    layer=self.layers['text']
                )
                cell.add(region_text)
        
        # Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© ÙÙŠ Ø§Ù„Ø£Ø³ÙÙ„
        footer_info = [
            "Confidential - Quantum Sovereign Project",
            f"Chip ID: QSC-{datetime.now().strftime('%Y%m%d')}-001",
            "Layer 1: Siâ‚ƒNâ‚„ (Waveguides) | Layer 2: AlGaAs (Nonlinear)",
            "Layer 10: TiN (Heaters) | Layer 11: Ti (Vias)"
        ]
        
        for i, line in enumerate(footer_info):
            text = gdspy.Text(
                line,
                20,
                (self.chip_width/2, 300 + i * 30),
                layer=self.layers['text']
            )
            cell.add(text)
        
        return cell
    
    def _create_dicing_streets(self) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ Ø´ÙˆØ§Ø±Ø¹ Ø§Ù„Ù‚Ø·Ø¹ Ø­ÙˆÙ„ Ø§Ù„Ø±Ù‚Ø§Ù‚Ø©."""
        cell = gdspy.Cell("DICING_STREETS")
        
        street_width = 100.0  # Ø¹Ø±Ø¶ Ø´Ø§Ø±Ø¹ Ø§Ù„Ù‚Ø·Ø¹
        
        # Ø§Ù„Ø´ÙˆØ§Ø±Ø¹ Ø§Ù„Ø£ÙÙ‚ÙŠØ© (Ø£Ø¹Ù„Ù‰ ÙˆØ£Ø³ÙÙ„)
        horizontal_streets = [
            gdspy.Rectangle(
                (0, 0),
                (self.chip_width, street_width),
                layer=self.layers['dicing']
            ),
            gdspy.Rectangle(
                (0, self.chip_height - street_width),
                (self.chip_width, self.chip_height),
                layer=self.layers['dicing']
            )
        ]
        
        # Ø§Ù„Ø´ÙˆØ§Ø±Ø¹ Ø§Ù„Ø±Ø£Ø³ÙŠØ© (ÙŠÙ…ÙŠÙ† ÙˆÙŠØ³Ø§Ø±)
        vertical_streets = [
            gdspy.Rectangle(
                (0, 0),
                (street_width, self.chip_height),
                layer=self.layers['dicing']
            ),
            gdspy.Rectangle(
                (self.chip_width - street_width, 0),
                (self.chip_width, self.chip_height),
                layer=self.layers['dicing']
            )
        ]
        
        # Ø®Ø·ÙˆØ· Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ© (Ù„Ù„ØªÙˆØ¬ÙŠÙ‡)
        for i in range(1, 4):
            # Ø®Ø·ÙˆØ· Ø£ÙÙ‚ÙŠØ©
            h_line = gdspy.Rectangle(
                (0, i * self.chip_height/4 - 5),
                (self.chip_width, i * self.chip_height/4 + 5),
                layer=self.layers['dicing']
            )
            
            # Ø®Ø·ÙˆØ· Ø±Ø£Ø³ÙŠØ©
            v_line = gdspy.Rectangle(
                (i * self.chip_width/4 - 5, 0),
                (i * self.chip_width/4 + 5, self.chip_height),
                layer=self.layers['dicing']
            )
            
            cell.add(h_line)
            cell.add(v_line)
        
        cell.add(horizontal_streets)
        cell.add(vertical_streets)
        
        # Ø¥Ø¶Ø§ÙØ© Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ù‚Ø·Ø¹
        cut_marks = self._create_cut_marks()
        cell.add(cut_marks)
        
        return cell
    
    def _create_cut_marks(self) -> gdspy.Cell:
        """Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ù‚Ø·Ø¹ ÙÙŠ Ø§Ù„Ø²ÙˆØ§ÙŠØ§."""
        cell = gdspy.Cell("CUT_MARKS")
        
        mark_size = 20
        mark_offset = 150  # Ù…Ù† Ø­Ø§ÙØ© Ø´Ø§Ø±Ø¹ Ø§Ù„Ù‚Ø·Ø¹
        
        # Ø§Ù„Ø²ÙˆØ§ÙŠØ§ Ø§Ù„Ø£Ø±Ø¨Ø¹
        corners = [
            (mark_offset, mark_offset),  # ÙŠØ³Ø§Ø±-Ø£Ø³ÙÙ„
            (self.chip_width - mark_offset, mark_offset),  # ÙŠÙ…ÙŠÙ†-Ø£Ø³ÙÙ„
            (mark_offset, self.chip_height - mark_offset),  # ÙŠØ³Ø§Ø±-Ø£Ø¹Ù„Ù‰
            (self.chip_width - mark_offset, self.chip_height - mark_offset)  # ÙŠÙ…ÙŠÙ†-Ø£Ø¹Ù„Ù‰
        ]
        
        for corner_x, corner_y in corners:
            # Ø¹Ù„Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø´ÙƒÙ„ L
            mark = gdspy.Polygon([
                (corner_x - mark_size/2, corner_y),
                (corner_x, corner_y),
                (corner_x, corner_y - mark_size/2),
                (corner_x + mark_size/2, corner_y - mark_size/2),
                (corner_x + mark_size/2, corner_y),
                (corner_x, corner_y),
                (corner_x, corner_y + mark_size/2),
                (corner_x - mark_size/2, corner_y + mark_size/2)
            ], layer=self.layers['dicing'])
            
            cell.add(mark)
        
        return cell
    
    def export_design(self, output_dir: str = "../layouts/gds") -> Dict:
        """ØªØµØ¯ÙŠØ± Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„ÙƒØ§Ù…Ù„ Ø¥Ù„Ù‰ Ù…Ù„Ù GDS."""
        import os
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù„Ø¯ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
        os.makedirs(output_dir, exist_ok=True)
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„ÙƒØ§Ù…Ù„
        print("\n" + "=" * 70)
        print("ØªØµØ¯ÙŠØ± Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„ÙƒØ§Ù…Ù„ Ù„Ù„Ø±Ù‚Ø§Ù‚Ø©...")
        print("=" * 70)
        
        main_cell = self.create_full_chip_design()
        
        # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø®Ù„ÙŠØ© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ù„Ù…ÙƒØªØ¨Ø©
        self.library.add(main_cell)
        
        # Ø§Ø³Ù… Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{self.chip_name}_{timestamp}.gds"
        filepath = os.path.join(output_dir, filename)
        
        # Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ù GDS
        self.library.write_gds(filepath)
        
        # Ø¥Ù†Ø´Ø§Ø¡ ØªÙ‚Ø±ÙŠØ± Ø§Ù„ØªØµÙ…ÙŠÙ…
        report = self._generate_design_report(filepath)
        
        print(f"\nâœ… ØªÙ… ØªØµØ¯ÙŠØ± Ø§Ù„ØªØµÙ…ÙŠÙ… Ø¨Ù†Ø¬Ø§Ø­!")
        print(f"ğŸ“ Ø§Ù„Ù…Ù„Ù: {filepath}")
        print(f"ğŸ“„ Ø§Ù„ØªÙ‚Ø±ÙŠØ±: {filepath.replace('.gds', '_report.txt')}")
        
        return {
            'filepath': filepath,
            'chip_name': self.chip_name,
            'version': self.version,
            'timestamp': timestamp,
            'report': report
        }
    
    def _generate_design_report(self, gds_filepath: str) -> str:
        """ØªÙˆÙ„ÙŠØ¯ ØªÙ‚Ø±ÙŠØ± Ù…ÙØµÙ„ Ø¹Ù† Ø§Ù„ØªØµÙ…ÙŠÙ…."""
        import os
        
        report = f"""
        ================================================================================
        ØªÙ‚Ø±ÙŠØ± ØªØµÙ…ÙŠÙ… Ø§Ù„Ø±Ù‚Ø§Ù‚Ø© Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ© Ø§Ù„Ø³ÙŠØ§Ø¯ÙŠØ©
        ========================================