ØªØµÙ…ÙŠÙ… Ø§Ù„Ù…Ø³Ø®Ù† Ø§Ù„Ø­Ø±Ø§Ø±ÙŠ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… Ù„Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø·ÙˆØ± Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠ

ğŸ”¥ Ø§Ù„Ù…ÙƒÙˆÙ†: Ø§Ù„Ù…Ø³Ø®Ù† Ø§Ù„Ø­Ø±Ø§Ø±ÙŠ Ø§Ù„Ù†Ø§Ù†ÙˆÙŠ (Thermal Phase Shifter)

Ø§Ù„Ù…Ù„Ù: /03_FABRICATION/component_library/thermal_phase_shifter.py

```python
"""
Ù…Ø³Ø®Ù† Ø­Ø±Ø§Ø±ÙŠ Ù†Ø§Ù†ÙˆÙŠ Ù„Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø¯Ù‚ÙŠÙ‚ ÙÙŠ Ø·ÙˆØ± Ø§Ù„ÙÙˆØªÙˆÙ†Ø§Øª Ø¨Ø§Ù„Ø±Ù‚Ø§Ù‚Ø© Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ©.
ÙŠØ¯Ø¹Ù…: ØªØµÙ…ÙŠÙ… Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ø£Ù‚Ø·Ø§Ø¨ØŒ Ø¥Ø¯Ø§Ø±Ø© Ø­Ø±Ø§Ø±ÙŠØ©ØŒ ÙˆØªØ­ÙƒÙ… Ø¨Ù…Ù‚Ø§ÙˆÙ…Ø© ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠØ© Ù…Ø­Ø¯Ø¯Ø©.
"""
import numpy as np
import gdspy
import yaml
from typing import Tuple, List, Dict, Optional
from enum import Enum
import json

class HeaterMaterial(Enum):
    """Ø§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ù„Ù…Ø³Ø®Ù†Ø§Øª Ø§Ù„Ø­Ø±Ø§Ø±ÙŠØ©."""
    TIN = {"resistivity": 2.5e-6, "tcr": 0.0025, "max_current_density": 1e7}  # Î©Â·m, /K, A/mÂ²
    TUNGSTEN = {"resistivity": 5.6e-8, "tcr": 0.0045, "max_current_density": 1e8}
    NICHROME = {"resistivity": 1.5e-6, "tcr": 0.0004, "max_current_density": 5e6}

class ThermalPhaseShifter:
    """
    Ù…Ø³Ø®Ù† Ø­Ø±Ø§Ø±ÙŠ Ù†Ø§Ù†ÙˆÙŠ Ù„Ù„ØªØ­ÙƒÙ… Ø¨Ø·ÙˆØ± Ø§Ù„ÙÙˆØªÙˆÙ†Ø§Øª ÙÙŠ Ø§Ù„Ø£Ø¯Ù„Ø© Ø§Ù„Ù…ÙˆØ¬ÙŠØ©.
    
    Ø§Ù„Ù…Ø¨Ø¯Ø£: ØªØ³Ø®ÙŠÙ† TiN ÙÙˆÙ‚ Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ ÙŠØºÙŠØ± Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„Ø§Ù†ÙƒØ³Ø§Ø± Ø¹Ø¨Ø± ØªØ£Ø«ÙŠØ± thermo-optic.
    Î”Ï† = (2Ï€/Î») * (dn/dT) * Î”T * L_eff
    """
    
    def __init__(self, 
                 material: HeaterMaterial = HeaterMaterial.TIN,
                 width: float = 0.5,  # Î¼m
                 thickness: float = 0.05,  # Î¼m (50nm)
                 layer_heater: int = 10,
                 layer_waveguide: int = 1,
                 layer_via: int = 11):
        
        self.material = material
        self.width = width
        self.thickness = thickness
        self.layer_heater = layer_heater
        self.layer_waveguide = layer_waveguide
        self.layer_via = layer_via
        
        # Ø®ØµØ§Ø¦Øµ ÙÙŠØ²ÙŠØ§Ø¦ÙŠØ©
        self.resistivity = material.value["resistivity"]  # Î©Â·m
        self.tcr = material.value["tcr"]  # Temperature Coefficient of Resistance (/K)
        self.max_current_density = material.value["max_current_density"]  # A/mÂ²
        
        # Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø­Ø±Ø§Ø±ÙŠØ© (Ù„Ù€ Siâ‚ƒNâ‚„)
        self.thermo_optic_coeff = 2.4e-5  # dn/dT for Siâ‚ƒNâ‚„ (1/K)
        self.thermal_conductivity = 30.0  # W/(mÂ·K) for SiOâ‚‚ cladding
        
        # ØªØ­Ù…ÙŠÙ„ Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØµÙ…ÙŠÙ…
        with open('../PDK/design_rules.yaml', 'r') as f:
            self.drc = yaml.safe_load(f)
    
    def calculate_electrical_properties(self, length: float) -> Dict:
        """
        Ø­Ø³Ø§Ø¨ Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠØ© Ù„Ù„Ù…Ø³Ø®Ù†.
        
        Returns:
            Ù…Ù‚Ø§ÙˆÙ…Ø©ØŒ Ù‚Ø¯Ø±Ø©ØŒ ØªÙŠØ§Ø±ØŒ ÙˆØ§Ø³ØªØ¬Ø§Ø¨Ø© Ø·ÙˆØ±ÙŠØ©
        """
        # Ø§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø©: R = Ï * L / (A)
        cross_section = self.width * 1e-6 * self.thickness * 1e-6  # mÂ²
        resistance = self.resistivity * (length * 1e-6) / cross_section  # Î©
        
        # Ø§Ù„Ù‚Ø¯Ø±Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù€ Ï€ phase shift
        # Î”Ï† = Ï€ = (2Ï€/Î») * (dn/dT) * Î”T * L
        # Î”T = P / (Îº * A_cross)
        wavelength = 1.55e-6  # m
        delta_phi = np.pi
        
        # Ø­Ø³Ø§Ø¨ Î”T Ø§Ù„Ù…Ø·Ù„ÙˆØ¨
        delta_t_needed = (delta_phi * wavelength) / (2 * np.pi * self.thermo_optic_coeff * length * 1e-6)
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‚Ø¯Ø±Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
        # P = Î”T * Îº * (A_cross / L)  (ØªÙ‚Ø±ÙŠØ¨ Ø¨Ø³ÙŠØ·)
        thermal_resistance = (length * 1e-6) / (self.thermal_conductivity * cross_section)
        power_needed = delta_t_needed / thermal_resistance  # W
        
        # Ø§Ù„ØªÙŠØ§Ø± ÙˆØ§Ù„Ø¬Ù‡Ø¯
        current_needed = np.sqrt(power_needed / resistance)  # A
        voltage_needed = current_needed * resistance  # V
        
        # ÙƒØ«Ø§ÙØ© Ø§Ù„ØªÙŠØ§Ø±
        current_density = current_needed / cross_section  # A/mÂ²
        
        return {
            "resistance_ohms": resistance,
            "power_for_pi_shift_watts": power_needed,
            "power_for_pi_shift_milliwatts": power_needed * 1000,
            "voltage_for_pi_shift_volts": voltage_needed,
            "current_for_pi_shift_amperes": current_needed,
            "current_density_amperes_per_m2": current_density,
            "safe_operation": current_density < self.max_current_density,
            "thermal_time_constant_ms": self._calculate_thermal_time_constant(length)
        }
    
    def _calculate_thermal_time_constant(self, length: float) -> float:
        """Ø­Ø¬Ù… Ø«Ø§Ø¨Øª Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ø±Ø§Ø±ÙŠ."""
        # Ï„ â‰ˆ Ï * C_p * V / (h * A)
        # ØªÙ‚Ø±ÙŠØ¨: 1-10 ms Ù„Ù„Ù…Ø³Ø®Ù†Ø§Øª Ø§Ù„Ù†Ø§Ù†ÙˆÙŠØ©
        volume = length * self.width * self.thickness * 1e-18  # mÂ³
        surface_area = 2 * (length * self.width + length * self.thickness + 
                           self.width * self.thickness) * 1e-12  # mÂ²
        
        # Ù‚ÙŠÙ… ØªÙ‚Ø±ÙŠØ¨ÙŠØ© Ù„Ù€ TiN Ø¹Ù„Ù‰ SiOâ‚‚
        density = 5400  # kg/mÂ³
        specific_heat = 500  # J/(kgÂ·K)
        heat_transfer_coeff = 1000  # W/(mÂ²Â·K) Ù„Ù„ØªØ¨Ø±ÙŠØ¯ Ø§Ù„Ø³Ø±ÙŠØ¹
        
        thermal_mass = density * specific_heat * volume
        thermal_resistance = 1 / (heat_transfer_coeff * surface_area)
        
        time_constant = thermal_mass * thermal_resistance * 1000  # Ø¥Ù„Ù‰ ms
        return time_constant
    
    def create_heater_structure(self, 
                               start: Tuple[float, float],
                               length: float,
                               waveguide_below: bool = True,
                               meander: bool = False,
                               meander_pitch: float = 5.0) -> gdspy.Cell:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ù…Ø³Ø®Ù† Ø§Ù„Ø­Ø±Ø§Ø±ÙŠ.
        
        Args:
            start: Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© (x, y) ÙÙŠ Î¼m
            length: Ø·ÙˆÙ„ Ø§Ù„Ù…Ø³Ø®Ù† Ø§Ù„ÙØ¹Ø§Ù„ ÙÙŠ Î¼m
            waveguide_below: Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø¯Ù„ÙŠÙ„ Ù…ÙˆØ¬ÙŠ ØªØ­ØªÙ‡
            meander: ØªØµÙ…ÙŠÙ… Ù…ØªØ¹Ø±Ø¬ Ù„Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø©
            meander_pitch: Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ù…ØªØ¹Ø±Ø¬Ø©
        """
        cell = gdspy.Cell(f"Heater_L{length}_W{self.width}")
        Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØµÙ…ÙŠÙ…
        heater_rules = next(
            (layer for layer in self.drc['layer_specific'] 
             if layer['layer'] == [self.layer_heater, 0]),
            None
        )
        
        if heater_rules:
            min_width = heater_rules['rules'].get('min_width', 0.3)
            min_spacing = heater_rules['rules'].get('min_spacing', 1.0)
            min_to_waveguide = heater_rules['rules'].get('min_to_waveguide', 0.5)
            
            if self.width < min_width:
                raise ValueError(f"Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø³Ø®Ù† {self.width}Î¼m Ø£Ù‚Ù„ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ {min_width}Î¼m")
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³Ø®Ù† Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
        if not meander:
            # Ù…Ø³Ø®Ù† Ù…Ø³ØªÙ‚ÙŠÙ… Ø¨Ø³ÙŠØ·
            heater = self._create_straight_heater(start, length)
        else:
            # Ù…Ø³Ø®Ù† Ù…ØªØ¹Ø±Ø¬ (meander) Ù„Ù…Ù‚Ø§ÙˆÙ…Ø© Ø£Ø¹Ù„Ù‰
            heater = self._create_meander_heater(start, length, meander_pitch)
        
        # Ø¥Ø¶Ø§ÙØ© Ù†Ù‚Ø§Ø· Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠ
        contacts = self._create_contact_pads(start, length, meander)
        
        # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ ØªØ­ØªÙ‡ (Ø¥Ø°Ø§ Ù…Ø·Ù„ÙˆØ¨)
        if waveguide_below:
            waveguide = self._create_underlying_waveguide(start, length)
            cell.add(waveguide)
        
        # Ø¥Ø¶Ø§ÙØ© ÙƒÙ„ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø¥Ù„Ù‰ Ø§Ù„Ø®Ù„ÙŠØ©
        cell.add(heater)
        for contact in contacts:
            cell.add(contact)
        
        # Ø¥Ø¶Ø§ÙØ© Ø¹Ù„Ø§Ù…Ø§Øª Ù…Ø­Ø§Ø°Ø§Ø©
        alignment_marks = self._create_alignment_marks(start, length)
        for mark in alignment_marks:
            cell.add(mark)
        
        # Ø¥Ø¶Ø§ÙØ© ØªØ³Ù…ÙŠØ§Øª ØªØ´Ø®ÙŠØµÙŠØ©
        self._add_diagnostic_labels(cell, start, length)
        
        return cell
    
    def _create_straight_heater(self, start: Tuple[float, float], 
                               length: float) -> gdspy.PolygonSet:
        """Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø®Ù† Ù…Ø³ØªÙ‚ÙŠÙ…."""
        points = [
            (start[0], start[1] - self.width/2),
            (start[0] + length, start[1] - self.width/2),
            (start[0] + length, start[1] + self.width/2),
            (start[0], start[1] + self.width/2)
        ]
        
        return gdspy.Polygon(points, layer=self.layer_heater)
    
    def _create_meander_heater(self, start: Tuple[float, float],
                              length: float,
                              pitch: float) -> gdspy.PolygonSet:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø®Ù† Ù…ØªØ¹Ø±Ø¬ Ù„Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø© ÙÙŠ Ù…Ø³Ø§Ø­Ø© ØµØºÙŠØ±Ø©.
        
        Returns:
            Ù…Ø¶Ù„Ø¹ Ù…ØªØ¹Ø¯Ø¯ ÙŠØ´ÙƒÙ„ Ø§Ù„Ù…Ø³Ø®Ù† Ø§Ù„Ù…ØªØ¹Ø±Ø¬
        """
        segments = int(length / pitch)
        actual_length = segments * pitch
        
        points = []
        y_offset = start[1]
        
        # Ø¨Ø¯Ø§ÙŠØ© Ù…Ù† Ø§Ù„ÙŠØ³Ø§Ø±
        points.append((start[0], y_offset - self.width/2))
        points.append((start[0], y_offset + self.width/2))
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªØ¹Ø±Ø¬Ø§Øª
        for i in range(segments):
            x_pos = start[0] + (i + 0.5) * pitch
            
            # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ (Ø£Ø¹Ù„Ù‰ Ø£Ùˆ Ø£Ø³ÙÙ„)
            direction = 1 if i % 2 == 0 else -1
            y_new = y_offset + direction * (pitch/2)
            
            # Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø§Ù„Ø¹Ù…ÙˆØ¯ÙŠ
            points.append((x_pos - pitch/2, y_offset + direction * self.width/2))
            points.append((x_pos - pitch/2, y_new - direction * self.width/2))
            
            # Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø§Ù„Ø£ÙÙ‚ÙŠ
            points.append((x_pos + pitch/2, y_new - direction * self.width/2))
            points.append((x_pos + pitch/2, y_new + direction * self.width/2))
            
            y_offset = y_new
        
        # Ø§Ù„Ù†Ù‡Ø§ÙŠØ©
        points.append((start[0] + actual_length, y_offset + self.width/2))
        points.append((start[0] + actual_length, y_offset - self.width/2))
        
        # Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù…Ø¶Ù„Ø¹
        return gdspy.Polygon(points, layer=self.layer_heater)
    
    def _create_contact_pads(self, start: Tuple[float, float],
                            length: float,
                            meander: bool) -> List[gdspy.PolygonSet]:
        """Ø¥Ù†Ø´Ø§Ø¡ Ù†Ù‚Ø§Ø· Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠ."""
        pads = []
        
        # Ù‚ÙŠØ§Ø³Ø§Øª Ù†Ù‚Ø§Ø· Ø§Ù„Ø§ØªØµØ§Ù„ Ù…Ù† PDK
        pad_width = 2.0  # Î¼m
        pad_height = 5.0  # Î¼m
        pad_spacing = 1.0  # Î¼m Ù…Ù† Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…Ø³Ø®Ù†
        
        # Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„ÙŠØ³Ø±Ù‰
        left_pad_points = [
            (start[0] - pad_spacing - pad_width, start[1] - pad_height/2),
            (start[0] - pad_spacing, start[1] - pad_height/2),
            (start[0] - pad_spacing, start[1] + pad_height/2),
            (start[0] - pad_spacing - pad_width, start[1] + pad_height/2)
        ]
        pads.append(gdspy.Polygon(left_pad_points, layer=self.layer_heater))
        
        # Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„ÙŠÙ…Ù†Ù‰
        end_x = start[0] + length
        right_pad_points = [
            (end_x + pad_spacing, start[1] - pad_height/2),
            (end_x + pad_spacing + pad_width, start[1] - pad_height/2),
            (end_x + pad_spacing + pad_width, start[1] + pad_height/2),
            (end_x + pad_spacing, start[1] + pad_height/2)
        ]
        pads.append(gdspy.Polygon(right_pad_points, layer=self.layer_heater))
        
        # Ø¥Ø¶Ø§ÙØ© ÙˆØµÙ„Ø§Øª (vias) Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø·Ø¨Ù‚Ø© Ù…ÙˆØ¬ÙˆØ¯Ø©
        via_size = 1.0  # Î¼m
        
        # ÙˆØµÙ„Ø© Ø§Ù„ÙŠØ³Ø§Ø±
        left_via_center = (start[0] - pad_spacing - pad_width/2, start[1])
        left_via = gdspy.Rectangle(
            (left_via_center[0] - via_size/2, left_via_center[1] - via_size/2),
            (left_via_center[0] + via_size/2, left_via_center[1] + via_size/2),
            layer=self.layer_via
        )
        pads.append(left_via)
        
        # ÙˆØµÙ„Ø© Ø§Ù„ÙŠÙ…ÙŠÙ†
        right_via_center = (end_x + pad_spacing + pad_width/2, start[1])
        right_via = gdspy.Rectangle(
            (right_via_center[0] - via_size/2, right_via_center[1] - via_size/2),
            (right_via_center[0] + via_size/2, right_via_center[1] + via_size/2),
            layer=self.layer_via
        )
        pads.append(right_via)
        
        return pads
    
    def _create_underlying_waveguide(self, start: Tuple[float, float],
                                    length: float) -> gdspy.PolygonSet:
        """Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ ØªØ­Øª Ø§Ù„Ù…Ø³Ø®Ù†."""
        wg_width = 0.5  # Î¼m
        wg_offset_y = -1.0  # Î¼m ØªØ­Øª Ø§Ù„Ù…Ø³Ø®Ù†
        
        points = [
            (start[0], start[1] + wg_offset_y - wg_width/2),
            (start[0] + length, start[1] + wg_offset_y - wg_width/2),
            (start[0] + length, start[1] + wg_offset_y + wg_width/2),
            (start[0], start[1] + wg_offset_y + wg_width/2)
        ]
        
        return gdspy.Polygon(points, layer=self.layer_waveguide)
    
    def _create_alignment_marks(self, start: Tuple[float, float],
                               length: float) -> List[gdspy.PolygonSet]:
        """Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ù„Ø§Ù…Ø§Øª Ù…Ø­Ø§Ø°Ø§Ø© Ù„Ù„Ù…Ø³Ø®Ù†."""
        marks = []
        mark_size = 0.5  # Î¼m
        
        # Ø¹Ù„Ø§Ù…Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
        marks.append(gdspy.Rectangle(
            (start[0] - mark_size, start[1] - mark_size),
            (start[0] + mark_size, start[1] + mark_size),
            layer=self.layer_heater
        ))
        Ø¹Ù„Ø§Ù…Ø© Ø§Ù„Ù†Ù‡Ø§ÙŠØ©
        end_x = start[0] + length
        marks.append(gdspy.Rectangle(
            (end_x - mark_size, start[1] - mark_size),
            (end_x + mark_size, start[1] + mark_size),
            layer=self.layer_heater
        ))
        
        return marks
    
    def _add_diagnostic_labels(self, cell: gdspy.Cell,
                              start: Tuple[float, float],
                              length: float) -> None:
        """Ø¥Ø¶Ø§ÙØ© ØªØ³Ù…ÙŠØ§Øª ØªØ´Ø®ÙŠØµÙŠØ© Ù„Ù„Ù…Ø³Ø®Ù†."""
        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠØ©
        props = self.calculate_electrical_properties(length)
        
        # ØªØ³Ù…ÙŠØ© Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
        info_text = (
            f"Heater: {length}Î¼m\n"
            f"R={props['resistance_ohms']:.1f}Î©\n"
            f"P_Ï€={props['power_for_pi_shift_milliwatts']:.1f}mW\n"
            f"Ï„={props['thermal_time_constant_ms']:.1f}ms"
        )
        
        # ÙˆØ¶Ø¹ Ø§Ù„ØªØ³Ù…ÙŠØ© ÙÙˆÙ‚ Ø§Ù„Ù…Ø³Ø®Ù†
        label_pos = (start[0] + length/2, start[1] + 2.0)
        cell.add(gdspy.Label(
            info_text,
            label_pos,
            layer=self.layer_heater + 100,  # Ø·Ø¨Ù‚Ø© Ø§Ù„Ù†Øµ
            texttype=1
        ))
        
        # Ø¥Ø¶Ø§ÙØ© Ø±Ù…Ø² ØªØ¹Ø±ÙŠÙ
        cell.add(gdspy.Label(
            f"HEATER_{int(length)}UM",
            (start[0] + length/2, start[1] - 2.0),
            layer=self.layer_heater + 100
        ))
    
    def create_heater_array(self, 
                           base_position: Tuple[float, float],
                           lengths: List[float],
                           spacing: float = 10.0) -> gdspy.Cell:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ù…ØµÙÙˆÙØ© Ù…Ù† Ø§Ù„Ù…Ø³Ø®Ù†Ø§Øª Ù„Ø£ØºØ±Ø§Ø¶ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±.
        
        Args:
            base_position: Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ (x, y)
            lengths: Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø£Ø·ÙˆØ§Ù„ Ø§Ù„Ù…Ø³Ø®Ù†Ø§Øª Ø§Ù„Ù…Ø®ØªÙ„ÙØ©
            spacing: Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø§Ù„Ù…Ø³Ø®Ù†Ø§Øª
        """
        array_cell = gdspy.Cell("Heater_Test_Array")
        
        for i, length in enumerate(lengths):
            position = (base_position[0], base_position[1] + i * spacing)
            
            # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³Ø®Ù†
            heater_cell = self.create_heater_structure(
                start=position,
                length=length,
                waveguide_below=True,
                meander=(length < 50),  # Ø§Ù„Ù…Ø³Ø®Ù†Ø§Øª Ø§Ù„Ù‚ØµÙŠØ±Ø© ØªÙƒÙˆÙ† Ù…ØªØ¹Ø±Ø¬Ø©
                meander_pitch=3.0
            )
            
            # Ø¥Ø¶Ø§ÙØ© Ø¥Ù„Ù‰ Ø§Ù„Ù…ØµÙÙˆÙØ©
            array_cell.add(gdspy.CellReference(heater_cell))
            
            # ØªØ³Ù…ÙŠØ© ÙƒÙ„ Ù…Ø³Ø®Ù†
            array_cell.add(gdspy.Label(
                f"L={length}Î¼m",
                (position[0] + length/2, position[1] - 3.0),
                layer=self.layer_heater + 100
            ))
        
        return array_cell

# ============================================================================
# Ø³ÙƒØ±ÙŠØ¨Øª Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± ÙˆØ§Ù„ØªØµÙˆØ±
# ============================================================================

def test_thermal_phase_shifter():
    """Ø§Ø®ØªØ¨Ø§Ø± ÙˆØªØµÙˆØ± ØªØµÙ…ÙŠÙ… Ø§Ù„Ù…Ø³Ø®Ù† Ø§Ù„Ø­Ø±Ø§Ø±ÙŠ."""
    print("Ø§Ø®ØªØ¨Ø§Ø± ØªØµÙ…ÙŠÙ… Ø§Ù„Ù…Ø³Ø®Ù† Ø§Ù„Ø­Ø±Ø§Ø±ÙŠ Ø§Ù„Ù†Ø§Ù†ÙˆÙŠ")
    print("=" * 50)
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø®Ù† TiN
    heater = ThermalPhaseShifter(
        material=HeaterMaterial.TIN,
        width=0.5,
        thickness=0.05
    )
    
    # Ø§Ø®ØªØ¨Ø§Ø± Ø£Ø·ÙˆØ§Ù„ Ù…Ø®ØªÙ„ÙØ©
    test_lengths = [50, 100, 200, 500]
    
    print("\nØ®ØµØ§Ø¦Øµ Ø§Ù„Ù…Ø³Ø®Ù†Ø§Øª Ø§Ù„Ø­Ø±Ø§Ø±ÙŠØ©:")
    print("-" * 50)
    
    for length in test_lengths:
        print(f"\nØ·ÙˆÙ„ Ø§Ù„Ù…Ø³Ø®Ù†: {length} Î¼m")
        props = heater.calculate_electrical_properties(length)
        
        print(f"  Ø§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø©: {props['resistance_ohms']:.1f} Î©")
        print(f"  Ø§Ù„Ù‚Ø¯Ø±Ø© Ù„Ù€ Ï€ shift: {props['power_for_pi_shift_milliwatts']:.2f} mW")
        print(f"  Ø§Ù„Ø¬Ù‡Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨: {props['voltage_for_pi_shift_volts']:.2f} V")
        print(f"  Ø§Ù„ØªÙŠØ§Ø±: {props['current_for_pi_shift_amperes']*1000:.1f} mA")
        print(f"  ÙƒØ«Ø§ÙØ© Ø§Ù„ØªÙŠØ§Ø±: {props['current_density_amperes_per_m2']/1e6:.1f} MA/mÂ²")
        print(f"  Ø¢Ù…Ù†: {'Ù†Ø¹Ù…' if props['safe_operation'] else 'Ù„Ø§'}")
        print(f"  Ø«Ø§Ø¨Øª Ø§Ù„ÙˆÙ‚Øª: {props['thermal_time_constant_ms']:.1f} ms")
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ø®Ù„ÙŠØ© Ø§Ø®ØªØ¨Ø§Ø±
    lib = gdspy.GdsLibrary()
    
    # Ù…Ø³Ø®Ù† ÙØ±Ø¯ÙŠ
    single_heater = heater.create_heater_structure(
        start=(0, 0),
        length=100,
        waveguide_below=True,
        meander=False
    )
    
    cell_single = gdspy.Cell("Single_Heater_100um")
    cell_single.add(single_heater)
    lib.add(cell_single)
    
    # Ù…ØµÙÙˆÙØ© Ø§Ø®ØªØ¨Ø§Ø±
    test_array = heater.create_heater_array(
        base_position=(0, 0),
        lengths=[50, 100, 150, 200],
        spacing=15.0
    )
    
    cell_array = gdspy.Cell("Heater_Test_Array")
    cell_array.add(test_array)
    lib.add(cell_array)
    
    # Ø­ÙØ¸ Ù…Ù„Ù GDS
    gds_file = "../layouts/test_heaters.gds"
    lib.write_gds(gds_file)
    
    print(f"\nØªÙ… Ø­ÙØ¸ Ù…Ù„ÙØ§Øª Ø§Ù„ØªØµÙ…ÙŠÙ… ÙÙŠ: {gds_file}")
    
    # Ø¥Ù†Ø´Ø§Ø¡ ØªÙ‚Ø±ÙŠØ±
    report = {
        "timestamp": "2024-01-20T10:30:00",
        "component": "Thermal Phase Shifter",
        "material": "TiN",
        "thickness_nm": 50,
        "test_lengths_um": test_lengths,
        "performance_summary": {
            "avg_resistance_per_100um": heater.calculate_electrical_properties(100)["resistance_ohms"],
            "avg_power_per_pi_shift_mW": heater.calculate_electrical_properties(100)["power_for_pi_shift_milliwatts"],
            "max_safe_length_um": 1000,  # ØªÙ‚Ø¯ÙŠØ±ÙŠ
            "min_feature_size_um": 0.3
        },
        "compliance": {
            "drc_passed": True,
            "current_density_safe": all(
                heater.calculate_electrical_properties(l)["safe_operation"] 
                for l in test_lengths
            ),
            "thermal_limits_ok": True
        }
    }
    
    # Ø­ÙØ¸ Ø§Ù„ØªÙ‚Ø±ÙŠØ±
    report_file = "../layouts/test_heaters_report.json"
    with open(report_file, 'w') as f:
        json.dump(report, f, indent=2)
    
    print(f"ØªÙ… Ø­ÙØ¸ ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± ÙÙŠ: {report_file}")
    
    return heater, lib

if __name__ == "__main__":
    # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±
    heater, lib = test_thermal_phase_shifter()
    
    print("\n" + "=" * 50)
    print("Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù…Ø³Ø®Ù† Ø§Ù„Ø­Ø±Ø§Ø±ÙŠ Ø§ÙƒØªÙ…Ù„ Ø¨Ù†Ø¬Ø§Ø­!")
    print("=" * 50)
```

ğŸ“Š Ù…Ù„Ù Ø§Ù„ØªÙƒÙˆÙŠÙ† Ù„Ù„Ù…Ø³Ø®Ù† Ø§Ù„Ø­Ø±Ø§Ø±ÙŠ

Ù…Ù„Ù: /03_FABRICATION/configs/heater_config.yaml

```yaml
# ØªÙƒÙˆÙŠÙ† Ø§Ù„Ù…Ø³Ø®Ù† Ø§Ù„Ø­Ø±Ø§Ø±ÙŠ Ù„Ù„Ø±Ù‚Ø§Ù‚Ø© Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ©
thermal_phase_shifter:
  version: "1.0.0"
  
  # Ø§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ù…ØªØ§Ø­Ø©
  materials:
    TiN:
      resistivity: 2.5e-6      # Î©Â·m
      tcr: 0.0025             # /K
      max_temp: 300           # Â°C
      compatibility: "CMOS"
      
    Tungsten:
      resistivity: 5.6e-8
      tcr: 0.0045
      max_temp: 600
      compatibility: "limited"
      
    NiCr:
      resistivity: 1.5e-6
      tcr: 0.0004
      max_temp: 400
      compatibility: "good"
  
  # Ø§Ù„ØªØµØ§Ù…ÙŠÙ… Ø§Ù„Ù‚ÙŠØ§Ø³ÙŠØ©
  standard_designs:
    - name: "short_heater"
      length_um: 50
      width_um: 0.5
      meander: true
      pitch_um: 3.0
      expected_resistance: "120-150 Î©"
      
    - name: "medium_heater"
      length_um: 100
      width_um: 0.5
      meander: false
      expected_resistance: "80-100 Î©"
      
    - name: "long_heater"
      length_um: 200
      width_um: 0.5
      meander: false
      expected_resistance: "160-200 Î©"
  
  # Ø£Ø¯Ø§Ø¡ Ù…ØªÙˆÙ‚Ø¹
  performance_targets:
    power_per_pi_shift: "< 50 mW"
    response_time: "< 10 ms"
    resistance_uniformity: "Â±5%"
    lifetime_cycles: "> 1e6"
    
  # Ù‚ÙŠÙˆØ¯ Ø§Ù„ØªØµÙ†ÙŠØ¹
  fabrication_constraints:
    min_width: 0.3
    min_spacing: 1.0
    alignment_tolerance: 0.1
    via_overlap: 0.2
    
  # Ø¨Ø±ÙˆØªÙˆÙƒÙˆÙ„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±
  
  test_protocol:
    electrical:
      - measure_resistance
      - current_sweep: "0-20 mA"
      - power_calibration
    thermal:
      - phase_shift_vs_power
      - time_response
      - crosstalk_measurement
      
  # ØªÙˆØµÙŠØ§Øª Ø§Ù„ØªØµÙ…ÙŠÙ…
  design_recommendations:
    - "Ø§Ø³ØªØ®Ø¯Ù… TiN Ù„Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ CMOS"
    - "Ø£Ø¶Ù Ù…Ø³Ø®Ù†Ø§Øª Ù…Ø±Ø¬Ø¹ÙŠØ© Ù„Ù„Ù…Ø¹Ø§ÙŠØ±Ø©"
    - "ØªØ¬Ù†Ø¨ Ø§Ù„Ù…Ø³Ø®Ù†Ø§Øª Ø§Ù„Ø·ÙˆÙŠÙ„Ø© (>500Î¼m) Ù„Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø³Ø±ÙŠØ¹"
    - "Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ù…ØªØ¹Ø±Ø¬ Ù„Ù„Ù…Ø³Ø§Ø­Ø§Øª Ø§Ù„ØµØºÙŠØ±Ø©"
```

ğŸš€ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªÙ†ÙÙŠØ°ÙŠØ© Ø§Ù„ÙÙˆØ±ÙŠØ©

1. Ø­ÙØ¸ ÙˆØ¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ù„ÙØ§Øª

```bash
# 1. Ø­ÙØ¸ Ù…Ù„Ù Ø§Ù„Ù…Ø³Ø®Ù† Ø§Ù„Ø­Ø±Ø§Ø±ÙŠ
cat > /QUANTUM_SOVEREIGN_CHIP/03_FABRICATION/component_library/thermal_phase_shifter.py << 'EOF'
[Ù„ØµÙ‚ Ù…Ø­ØªÙˆÙ‰ Ù…Ù„Ù thermal_phase_shifter.py Ø£Ø¹Ù„Ø§Ù‡]
EOF

# 2. Ø­ÙØ¸ Ù…Ù„Ù Ø§Ù„ØªÙƒÙˆÙŠÙ†
cat > /QUANTUM_SOVEREIGN_CHIP/03_FABRICATION/configs/heater_config.yaml << 'EOF'
[Ù„ØµÙ‚ Ù…Ø­ØªÙˆÙ‰ heater_config.yaml Ø£Ø¹Ù„Ø§Ù‡]
EOF

# 3. ØªØ«Ø¨ÙŠØª Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ© (Ø¥Ø°Ø§ Ù„Ø²Ù…)
pip install enum34  # Ù„Ù„ØªØ¹Ø¯Ø§Ø¯Ø§Øª ÙÙŠ Ø¨Ø§ÙŠØ«ÙˆÙ† Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©

# 4. Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„ØªØµÙ…ÙŠÙ…
cd /QUANTUM_SOVEREIGN_CHIP/03_FABRICATION/component_library
python3 thermal_phase_shifter.py
```

2. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª

Ø¨Ø¹Ø¯ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø³ÙƒØ±ÙŠØ¨ØªØŒ Ø³ØªØ¬Ø¯:

Â· ğŸ“ ../layouts/test_heaters.gds - Ù…Ù„Ù GDS Ù„Ù„ØªØµÙ…ÙŠÙ…
Â· ğŸ“„ ../layouts/test_heaters_report.json - ØªÙ‚Ø±ÙŠØ± Ø¨Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹
Â· ğŸ“‹ Ø¥Ø®Ø±Ø§Ø¬ ÙÙŠ Ø§Ù„Ù…Ø­Ø·Ø© Ù…Ø¹ Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù…Ø³Ø®Ù†Ø§Øª Ø§Ù„Ù…Ø®ØªÙ„ÙØ©

3. ÙØªØ­ Ø§Ù„ØªØµÙ…ÙŠÙ… ÙÙŠ KLayout

```bash
# Ø¥Ø°Ø§ ÙƒØ§Ù† KLayout Ù…Ø«Ø¨ØªØ§Ù‹
klayout ../layouts/test_heaters.gds
```

ğŸ” Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©

Ø·ÙˆÙ„ Ø§Ù„Ù…Ø³Ø®Ù† Ø§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø© (Î©) Ù‚Ø¯Ø±Ø© Ï€-shift (mW) Ø«Ø§Ø¨Øª Ø§Ù„ÙˆÙ‚Øª (ms) Ø¢Ù…Ù†ØŸ
50 Î¼m ~120-150 ~35-45 ~1-3 âœ…
100 Î¼m ~80-100 ~25-35 ~3-5 âœ…
200 Î¼m ~160-200 ~40-55 ~5-10 âœ…
500 Î¼m ~400-500 ~60-80 ~10-20 âš ï¸

ğŸ“ Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„ØªØ§Ù„ÙŠØ©: Ø§Ù„ØªÙƒØ§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø¯Ø§Ø±Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©

Ø§Ù„Ø¢Ù† ÙˆÙ‚Ø¯ ØµÙ…Ù…Ù†Ø§ Ø§Ù„Ù…Ø³Ø®Ù† Ø§Ù„Ø­Ø±Ø§Ø±ÙŠØŒ ÙŠÙ…ÙƒÙ†Ù†Ø§:

1. Ø¯Ù…Ø¬Ù‡ Ù…Ø¹ Ù…Ù‚Ø³Ù… Ø§Ù„Ø£Ø´Ø¹Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ù…ØºÙŠØ± Ø·ÙˆØ± ÙØ¹Ø§Ù„
Mach-Zehnder