ØªØµÙ…ÙŠÙ… Ø¯Ø§Ø±Ø© Bell State Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„Ø©

ğŸ¯ Ø¯Ø§Ø±Ø© ØªÙˆÙ„ÙŠØ¯ ÙˆØªØ´Ø§Ø¨Ùƒ Ø­Ø§Ù„Ø© Bell Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ©

Ù…Ù„Ù: /03_FABRICATION/component_library/bell_state_generator.py

```python
"""
Ø¯Ø§Ø±Ø© Ù…ØªÙƒØ§Ù…Ù„Ø© Ù„ØªÙˆÙ„ÙŠØ¯ Ø­Ø§Ù„Ø© Bell Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ© |Î¨â»âŸ© Ø¹Ù„Ù‰ Ø±Ù‚Ø§Ù‚Ø© ÙˆØ§Ø­Ø¯Ø©.
ØªØ¯Ù…Ø¬: Ù…ØµØ§Ø¯Ø± SPDCØŒ Ù…Ù‚Ø³Ù…Ø§Øª Ø£Ø´Ø¹Ø©ØŒ Ù…Ø³Ø®Ù†Ø§Øª Ø­Ø±Ø§Ø±ÙŠØ©ØŒ ÙˆÙƒÙˆØ§Ø´Ù.
"""
import numpy as np
import gdspy
import yaml
from typing import Tuple, List, Dict, Optional
import json
import sys
import os

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from component_library.programmable_mzi import ProgrammableMZI
from component_library.thermal_phase_shifter import ThermalPhaseShifter, HeaterMaterial
from component_library.waveguide import QuantumWaveguide

class BellStateGenerator:
    """
    Ø¯Ø§Ø±Ø© ÙƒÙ…ÙˆÙ…ÙŠØ© Ù…ØªÙƒØ§Ù…Ù„Ø© Ù„ØªÙˆÙ„ÙŠØ¯ Ø­Ø§Ù„Ø© Bell |Î¨â»âŸ© = (|HVâŸ© - |VHâŸ©)/âˆš2
    
    Ø§Ù„Ù…Ø®Ø·Ø·:
        Pump Laser â†’ SPDC Source â†’ Polarization Splitting â†’ MZI Network â†’ Output
    """
    
    def __init__(self,
                 chip_size: Tuple[float, float] = (500, 500),  # Î¼m
                 wavelength: float = 1.55,  # Î¼m
                 material: str = "AlGaAs",
                 layer_spdc: int = 2,  # Ø·Ø¨Ù‚Ø© Ø§Ù„Ø¹Ù†Ø§ØµØ± ØºÙŠØ± Ø§Ù„Ø®Ø·ÙŠØ©
                 layer_waveguide: int = 1,
                 layer_heater: int = 10,
                 layer_detector: int = 20):
        
        self.chip_size = chip_size
        self.wavelength = wavelength
        self.material = material
        
        # Ø§Ù„Ø·Ø¨Ù‚Ø§Øª
        self.layer_spdc = layer_spdc
        self.layer_waveguide = layer_waveguide
        self.layer_heater = layer_heater
        self.layer_detector = layer_detector
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ©
        self.waveguide = QuantumWaveguide(width=0.5, layer=layer_waveguide)
        self.heater = ThermalPhaseShifter(
            material=HeaterMaterial.TIN,
            width=0.5,
            thickness=0.05,
            layer_heater=layer_heater,
            layer_waveguide=layer_waveguide,
            layer_via=11
        )
        
        # ØªØ­Ù…ÙŠÙ„ Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØµÙ…ÙŠÙ…
        with open('../PDK/design_rules.yaml', 'r') as f:
            self.drc = yaml.safe_load(f)
        
        # Ù…Ø¹Ø§Ù…Ù„Ø§Øª ÙÙŠØ²ÙŠØ§Ø¦ÙŠØ©
        self._calculate_quantum_properties()
    
    def _calculate_quantum_properties(self):
        """Ø­Ø³Ø§Ø¨ Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©."""
        # ÙƒÙØ§Ø¡Ø© ØªÙˆÙ„ÙŠØ¯ Ø£Ø²ÙˆØ§Ø¬ ÙÙˆØªÙˆÙ†Ø§Øª (SPDC)
        # P_pair = Î· * P_pumpÂ² * LÂ² * Ï‡Â²
        self.spdc_efficiency = 1e-8  # Ø£Ø²ÙˆØ§Ø¬/ÙÙˆØªÙˆÙ† Ù…Ø¶Ø®
        self.pair_generation_rate_hz = 1e5  # Ø¹Ù†Ø¯ 10 mW pump
        
        # Ù†Ù‚Ø§Ø¡ Ø§Ù„ØªØ´Ø§Ø¨Ùƒ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹
        self.expected_entanglement_purity = 0.95
        self.expected_fidelity = 0.98
        
        # Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¹Ø¯ÙˆØ¯ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹
        self.detection_efficiency = 0.8
        self.expected_coincidence_rate_hz = self.pair_generation_rate_hz * self.detection_efficiency**2
    
    def create_complete_circuit(self) -> gdspy.Cell:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ø§Ø±Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ù„ØªÙˆÙ„ÙŠØ¯ Ø­Ø§Ù„Ø© Bell.
        
        Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª:
        1. Ù…ØµØ¯Ø± SPDC ØºÙŠØ± Ø®Ø·ÙŠ
        2. ÙØµÙ„ Ø§Ù„Ø§Ø³ØªÙ‚Ø·Ø§Ø¨
        3. Ø´Ø¨ÙƒØ© MZI Ù„Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø·ÙˆØ±
        4. Ù…Ù†Ø·Ù‚ Ø§Ù„ØªØ´Ø§Ø¨Ùƒ (Bell State Measurement)
        5. Ù…Ù†Ø§Ø·Ù‚ Ø§Ù„ÙƒØ´Ù
        """
        cell = gdspy.Cell("Bell_State_Generator_v1")
        
        # 1. Ù…Ù†Ø·Ù‚Ø© Ù…ØµØ¯Ø± SPDC
        spdc_region = self._create_spdc_source((50, 250))
        cell.add(spdc_region)
        
        # 2. ÙØµÙ„ Ø§Ù„Ø§Ø³ØªÙ‚Ø·Ø§Ø¨ Ø¥Ù„Ù‰ Ù‚Ù†Ø§ØªÙŠÙ†
        polarization_splitter = self._create_polarization_splitter((150, 250))
        cell.add(polarization_splitter)
        
        # 3. Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„ÙÙˆØªÙˆÙ†Ø§Øª Ø§Ù„Ù…ØªØ´Ø§Ø¨ÙƒØ©
        photon_paths = self._create_entangled_photon_paths((250, 250))
        cell.add(photon_paths)
        
        # 4. Ø´Ø¨ÙƒØ© MZI Ù„Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø·ÙˆØ± ÙˆØ§Ù„ØªØ´Ø§Ø¨Ùƒ
        mzi_network = self._create_mzi_entanglement_network((350, 250))
        cell.add(mzi_network)
        
        # 5. Ù…Ù†Ø§Ø·Ù‚ Ø§Ù„ÙƒÙˆØ§Ø´Ù
        detectors = self._create_quantum_detectors((450, 250))
        cell.add(detectors)
        
        # 6. Ø¨Ù†ÙŠØ© ØªØ­ÙƒÙ… ÙˆØ§ØªØµØ§Ù„
        control_circuitry = self._create_control_circuitry()
        cell.add(control_circuitry)
        
        # 7. Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ø¯ÙˆØ¯ ÙˆØ§Ù„ØªØ³Ù…ÙŠØ§Øª
        border = self._create_chip_border()
        cell.add(border)
        
        labels = self._add_circuit_labels()
        for label in labels:
            cell.add(label)
        
        return cell
    
    def _create_spdc_source(self, center: Tuple[float, float]) -> gdspy.PolygonSet:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ù…ØµØ¯Ø± Ø£Ø²ÙˆØ§Ø¬ ÙÙˆØªÙˆÙ†Ø§Øª Ù…ØªØ´Ø§Ø¨ÙƒØ© Ø¹Ø¨Ø± SPDC.
        
        Ø§Ù„ØªØµÙ…ÙŠÙ…: Ø­Ù„Ù‚Ø© Ø±Ù†Ø§Ù†Ø© ØºÙŠØ± Ø®Ø·ÙŠØ© Ù…Ù† AlGaAs.
        """
        # Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ù†Ø§Ù†Ø©
        ring_radius = 20.0  # Î¼m
        ring_width = 0.5    # Î¼m
        bus_waveguide_offset = 0.2  # Î¼m
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        ring_circle = self._create_ring_resonator(center, ring_radius, ring_width)
        
        # Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø­Ø§ÙÙ„Ø© (Bus Waveguide) Ù„Ù„Ø¶Ø®
        bus_start = (center[0] - ring_radius - 10, center[1] + ring_radius + bus_waveguide_offset)
        bus_end = (center[0] + ring_radius + 10, center[1] + ring_radius + bus_waveguide_offset)
        bus_waveguide = self.waveguide.create_straight(bus_start, bus_end)
        
        # Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù†
        coupling_length = 5.0
        coupling_center = (center[0], center[1] + ring_radius + bus_waveguide_offset/2)
        coupling_region = gdspy.Rectangle(
            (coupling_center[0] - coupling_length/2, coupling_center[1] - 0.25),
            (coupling_center[0] + coupling_length/2, coupling_center[1] + 0.25),
            layer=self.layer_spdc
        )
        
        # Ø¥Ø¶Ø§ÙØ© ØªØ³Ù…ÙŠØ©
        label = gdspy.Label(
            f"SPDC_Source\nR={ring_radius}Î¼m\n{self.material}",
            (center[0], center[1] - ring_radius - 5),
            layer=self.layer_spdc + 100
        )
        
        # ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª
        spdc_source = gdspy.boolean([ring_circle, bus_waveguide, coupling_region], None, 'or')
        return spdc_source, label
    
    def _create_ring_resonator(self, center: Tuple[float, float], 
                              radius: float, width: float) -> gdspy.PolygonSet:
        """Ø¥Ù†Ø´Ø§Ø¡ Ø­Ù„Ù‚Ø© Ø±Ù†Ø§Ù†Ø© Ø¯Ø§Ø¦Ø±ÙŠØ©."""
        # ØªÙ‚Ø±ÙŠØ¨ Ø§Ù„Ø­Ù„Ù‚Ø© Ø¨Ù…Ø¶Ù„Ø¹ Ø°Ùˆ Ø¹Ø¯Ø¯ ÙƒØ¨ÙŠØ± Ù…Ù† Ø§Ù„Ø¬ÙˆØ§Ù†Ø¨
        num_points = 128
        angles = np.linspace(0, 2*np.pi, num_points, endpoint=False)
        
        # Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠØ©
        outer_points = []
        for angle in angles:
            x = center[0] + (radius + width/2) * np.cos(angle)
            y = center[1] + (radius + width/2) * np.sin(angle)
            outer_points.append((x, y))
        
        # Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ© (Ù…Ø¹ÙƒÙˆØ³Ø©)
        inner_points = []
        for angle in angles[::-1]:
            x = center[0] + (radius - width/2) * np.cos(angle)
            y = center[1] + (radius - width/2) * np.sin(angle)
            inner_points.append((x, y))
        
        # Ø¯Ù…Ø¬ Ø§Ù„Ù†Ù‚Ø§Ø· Ù„ØªØ´ÙƒÙŠÙ„ Ù…Ø¶Ù„Ø¹ Ø­Ù„Ù‚ÙŠ
        polygon_points = outer_points + inner_points
        
        return gdspy.Polygon(polygon_points, layer=self.layer_spdc)
    
    def _create_polarization_splitter(self, center: Tuple[float, float]) -> gdspy.PolygonSet:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø³Ù… Ø§Ø³ØªÙ‚Ø·Ø§Ø¨ Ù„ÙØµÙ„ |HâŸ© Ùˆ |VâŸ©.
        
        Ø§Ù„ØªØµÙ…ÙŠÙ…: Ù…Ù‚Ø³Ù… Ø£Ø´Ø¹Ø© ØºÙŠØ± Ù…ØªÙ…Ø§Ø«Ù„ Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬ Ø§Ø³ØªÙ‚Ø·Ø§Ø¨.
        """
        # Ø£Ø¨Ø¹Ø§Ø¯ Ù…Ù‚Ø³Ù… Ø§Ù„Ø§Ø³ØªÙ‚Ø·Ø§Ø¨
        length = 30.0
        width = 2.0
        
        # Ø§Ù„Ø¬Ø³Ù… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
        splitter_body = gdspy.Rectangle(
            (center[0] - length/2, center[1] - width/2),
            (center[0] + length/2, center[1] + width/2),
            layer=self.layer_waveguide
        )
        
        # Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø§Ù†Ù‚Ø³Ø§Ù…
        split_angle = np.pi/4  # 45 Ø¯Ø±Ø¬Ø©
        
        # Ø§Ù„Ø°Ø±Ø§Ø¹ H (Ø£ÙÙ‚ÙŠ)
        h_arm_start = (center[0] + length/2, center[1])
        h_arm_end = (center[0] + length/2 + 20, center[1])
        h_arm = self.waveguide.create_straight(h_arm_start, h_arm_end)
        
        # Ø§Ù„Ø°Ø±Ø§Ø¹ V (Ø¹Ù…ÙˆØ¯ÙŠ)
        v_arm_start = (center[0], center[1] + width/2)
        v_arm_end = (center[0], center[1] + width/2 + 20)
        v_arm = self.waveguide.create_straight(v_arm_start, v_arm_end)
        
        # Ø¥Ø¶Ø§ÙØ© Ù…Ø±Ø´Ø­Ø§Øª Ø§Ø³ØªÙ‚Ø·Ø§Ø¨ (ØªÙ…Ø«ÙŠÙ„ÙŠØ©)
        h_filter = gdspy.Rectangle(
            (h_arm_end[0] - 2, h_arm_end[1] - 1),
            (h_arm_end[0] + 2, h_arm_end[1] + 1),
            layer=self.layer_waveguide
        )
        
        v_filter = gdspy.Rectangle(
            (v_arm_end[0] - 1, v_arm_end[1] - 2),
            (v_arm_end[0] + 1, v_arm_end[1] + 2),
            layer=self.layer_waveguide
        )
        
        # ØªØ³Ù…ÙŠØ©
        label = gdspy.Label(
            "Polarization\nSplitter",
            (center[0], center[1] - width/2 - 5),
            layer=self.layer_waveguide + 100
        )
        
        # ØªØ¬Ù…ÙŠØ¹
        components = [splitter_body, h_arm, v_arm, h_filter, v_filter, label]
        return gdspy.boolean(components, None, 'or')
    
    def _create_entangled_photon_paths(self, start_point: Tuple[float, float]) -> gdspy.Cell:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ù„ÙÙˆØªÙˆÙ†ÙŠÙ† Ù…ØªØ´Ø§Ø¨ÙƒÙŠÙ†.
        
        Ù…Ø³Ø§Ø±Ø§Ù† Ù…ØªÙˆØ§Ø²ÙŠØ§Ù† Ù…Ø¹ Ù…Ù‚Ø³Ù…Ø§Øª Ø£Ø´Ø¹Ø© Ù„Ù„ØªØ­ÙƒÙ….
        """
        cell = gdspy.Cell("Entangled_Paths")
        
        # Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¹Ù„ÙˆÙŠ (Ø§Ù„ÙÙˆØªÙˆÙ† 1)
        top_path_y = start_point[1] + 10
        top_path_start = (start_point[0], top_path_y)
        top_path_end = (start_point[0] + 80, top_path_y)
        
        top_waveguide = self.waveguide.create_straight(top_path_start, top_path_end)
        cell.add(top_waveguide)
        
        # Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø³ÙÙ„ÙŠ (Ø§Ù„ÙÙˆØªÙˆÙ† 2)
        bottom_path_y = start_point[1] - 10
        bottom_path_start = (start_point[0], bottom_path_y)
        bottom_path_end = (start_point[0] + 80, bottom_path_y)
        
        bottom_waveguide = self.waveguide.create_straight(bottom_path_start, bottom_path_end)
        cell.add(bottom_waveguide)
        
        # Ù…Ù‚Ø³Ù… Ø£Ø´Ø¹Ø© Ø¨ÙŠÙ† Ø§Ù„Ù…Ø³Ø§Ø±ÙŠÙ† Ù„Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„ØªØ´Ø§Ø¨Ùƒ
        bs_center = (start_point[0] + 40, start_point[1])
        bs_coupler = self._create_directional_coupler(bs_center, length=20, gap=0.15)
        cell.add(bs_coupler)
        
        # Ù…Ø³Ø®Ù†Ø§Ù† Ù„Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø·ÙˆØ± Ø§Ù„Ù†Ø³Ø¨ÙŠ
        top_heater_start = (start_point[0] + 20, top_path_y + 1)
        top_heater = self.heater.create_heater_structure(
            start=top_heater_start,
            length=40,
            waveguide_below=True
        )
        cell.add(top_heater)
        
        bottom_heater_start = (start_point[0] + 20, bottom_path_y - 1)
        bottom_heater = self.heater.create_heater_structure(
            start=bottom_heater_start,
            length=40,
            waveguide_below=True
        )
        cell.add(bottom_heater)
        
        # ØªØ³Ù…ÙŠØ© Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
        cell.add(gdspy.Label("Photon 1 Path", 
                           (start_point[0] + 40, top_path_y + 3),
                           layer=self.layer_waveguide + 100))
        
        cell.add(gdspy.Label("Photon 2 Path", 
                           (start_point[0] + 40, bottom_path_y - 3),
                           layer=self.layer_waveguide + 100))
        
        return cell
    
    def _create_directional_coupler(self, center: Tuple[float, float], 
                                   length: float, gap: float) -> gdspy.PolygonSet:
        """Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø³Ù… Ø´Ø¹Ø§Ø¹ Ø§ØªØ¬Ø§Ù‡ÙŠ."""
        wg_width = 0.5
        
        # Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø¹Ù„ÙˆÙŠ
        upper_wg = gdspy.Rectangle(
            (center[0] - length/2, center[1] + gap/2 - wg_width/2),
            (center[0] + length/2, center[1] + gap/2 + wg_width/2),
            layer=self.layer_waveguide
        )
        
        # Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø³ÙÙ„ÙŠ
        lower_wg = gdspy.Rectangle(
            (center[0] - length/2, center[1] - gap/2 - wg_width/2),
            (center[0] + length/2, center[1] - gap/2 + wg_width/2),
            layer=self.layer_waveguide
        )
        
        return gdspy.boolean([upper_wg, lower_wg], None, 'or')
    
    def _create_mzi_entanglement_network(self, center: Tuple[float, float]) -> gdspy.Cell:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø¨ÙƒØ© MZI Ù„Ø¥Ù†ØªØ§Ø¬ Ø­Ø§Ù„Ø© Bell.
        
        Ø§Ù„Ù…Ø®Ø·Ø·:
            |HâŸ© â†’ MZI1 â†’ Output1
            |VâŸ© â†’ MZI2 â†’ Output2
        Ù…Ø¹ ÙˆØµÙ„Ø§Øª Ù…ØªÙ‚Ø§Ø·Ø¹Ø© Ù„Ø¥Ù†ØªØ§Ø¬ Ø§Ù„ØªØ´Ø§Ø¨Ùƒ.
        """
        cell = gdspy.Cell("MZI_Entanglement_Network")
        
        # MZI Ø§Ù„Ø£ÙˆÙ„ (Ù„Ù„Ø§Ø³ØªÙ‚Ø·Ø§Ø¨ H)
        mzi1 = ProgrammableMZI(
            coupling=0.5,
            arm_length=100,
            arm_spacing=8
        )
        
        mzi1_cell = mzi1.create_mzi_cell(
            start_point=(center[0] - 60, center[1] + 15),
            include_heaters=True,
            symmetric_heaters=True
        )
        cell.add(mzi1_cell)
        
        # MZI Ø§Ù„Ø«Ø§Ù†ÙŠ (Ù„Ù„Ø§Ø³ØªÙ‚Ø·Ø§Ø¨ V)
        mzi2 = ProgrammableMZI(
            coupling=0.5,
            arm_length=100,
            arm_spacing=8
        )
        
        mzi2_cell = mzi2.create_mzi_cell(
            start_point=(center[0] - 60, center[1] - 25),
            include_heaters=True,
            symmetric_heaters=True
        )
        cell.add(mzi2_cell)
        
        # ÙˆØµÙ„Ø© ØªÙ‚Ø§Ø·Ø¹ Ø¨ÙŠÙ† MZI Ù„Ø¥Ù†ØªØ§Ø¬ Ø§Ù„ØªØ´Ø§Ø¨Ùƒ
        cross_coupler = self._create_bell_state_cross_coupler(
            (center[0] + 50, center[1])
        )
        cell.add(cross_coupler)
        
        # ÙˆØµÙ„Ø§Øª Ø¨ÙŠÙ† MZI ÙˆØ§Ù„ØªÙ‚Ø§Ø·Ø¹
        connections = self._create_entanglement_connections(
            mzi1_position=(center[0] - 60, center[1] + 15),
            mzi2_position=(center[0] - 60, center[1] - 25),
            cross_position=(center[0] + 50, center[1])
        )
        
        for connection in connections:
            cell.add(connection)
        
        # ØªØ³Ù…ÙŠØ©
        cell.add(gdspy.Label("Bell State\nEntangler",
                           (center[0], center[1] + 30),
                           layer=self.layer_waveguide + 100))
        
        return cell
    
    def _create_bell_state_cross_coupler(self, center: Tuple[float, float]) -> gdspy.PolygonSet:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø³Ù… Ø´Ø¹Ø§Ø¹ Ù…ØªÙ‚Ø§Ø·Ø¹ Ù„Ø¥Ù†ØªØ§Ø¬ Ø­Ø§Ù„Ø© Bell.
        
        Ø§Ù„ØªØµÙ…ÙŠÙ…: Ù…Ù‚Ø³Ù…Ø§Ù† Ø£Ø´Ø¹Ø© Ø¹Ù…ÙˆØ¯ÙŠØ§Ù† Ø¹Ù„Ù‰ Ø¨Ø¹Ø¶Ù‡Ù…Ø§.
        """
        # Ø§Ù„Ù…Ù‚Ø³Ù… Ø§Ù„Ø£ÙÙ‚ÙŠ
        horizontal_coupler = self._create_directional_coupler(
            center=center,
            length=20,
            gap=0.15
        )
        
        # Ø§Ù„Ù…Ù‚Ø³Ù… Ø§Ù„Ø¹Ù…ÙˆØ¯ÙŠ (Ù…Ø¯ÙˆØ± 90 Ø¯Ø±Ø¬Ø©)
        vertical_center = (center[0], center[1])
        vertical_coupler = gdspy.Rectangle(
            (vertical_center[0] - 0.25, vertical_center[1] - 10),
            (vertical_center[0] + 0.25, vertical_center[1] + 10),
            layer=self.layer_waveguide
        )
        
        # Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…Ø±ÙƒØ²ÙŠØ© Ù„Ù„ØªÙ‚Ø§Ø·Ø¹
        cross_region = gdspy.Rectangle(
            (center[0] - 1, center[1] - 1),
            (center[0] + 1, center[1] + 1),
            layer=self.layer_waveguide
        )
        
        return gdspy.boolean([horizontal_coupler, vertical_coupler, cross_region], 
                           None, 'or')
    
    def _create_entanglement_connections(self, mzi1_position: Tuple[float, float],
                                        mzi2_position: Tuple[float, float],
                                        cross_position: Tuple[float, float]) -> List[gdspy.PolygonSet]:
        """Ø¥Ù†Ø´Ø§Ø¡ ÙˆØµÙ„Ø§Øª Ø§Ù„ØªØ´Ø§Ø¨Ùƒ Ø¨ÙŠÙ† MZI ÙˆØ§Ù„Ù…Ù‚Ø³Ù… Ø§Ù„Ù…ØªÙ‚Ø§Ø·Ø¹."""
        connections = []
        
        # Ù…Ù† MZI1 Ø¥Ù„Ù‰ Ø§Ù„ØªÙ‚Ø§Ø·Ø¹ (Ù…Ø³Ø§Ø± Ø¹Ù„ÙˆÙŠ)
        start1 = (mzi1_position[0] + 80, mzi1_position[1] + 10)
        end1 = (cross_position[0] - 10, cross_position[1] + 5)
        conn1 = self.waveguide.create_straight(start1, end1)
        connections.append(conn1)
        
        # Ù…Ù† MZI1 Ø¥Ù„Ù‰ Ø§Ù„ØªÙ‚Ø§Ø·Ø¹ (Ù…Ø³Ø§Ø± Ø³ÙÙ„ÙŠ)
        start2 = (mzi1_position[0] + 80, mzi1_position[1] - 10)
        end2 = (cross_position[0] - 10, cross_position[1] - 5)
        conn2 = self.waveguide.create_straight(start2, end2)
        connections.append(conn2)
        
        # Ù…Ù† MZI2 Ø¥Ù„Ù‰ Ø§Ù„ØªÙ‚Ø§Ø·Ø¹
        start3 = (mzi2_position[0] + 80, mzi2_position[1] + 10)
        end3 = (cross_position[0] - 10, cross_position[1] + 2)
        conn3 = self.waveguide.create_s_bend(start3, end3, offset=3)
        for component in conn3:
            connections.append(component)
        
        start4 = (mzi2_position[0] + 80, mzi2_position[1] - 10)
        end4 = (cross_position[0] - 10, cross_position[1] - 2)
        conn4 = self.waveguide.create_s_bend(start4, end4, offset=-3)
        for component in conn4:
            connections.append(component)
        
        return connections
    
    def _create_quantum_detectors(self, center: Tuple[float, float]) -> gdspy.Cell:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù†Ø§Ø·Ù‚ ÙƒØ´Ù Ø§Ù„ÙÙˆØªÙˆÙ†Ø§Øª Ø§Ù„Ù…ÙØ±Ø¯Ø©.
        
        ØªÙ…Ø«ÙŠÙ„ Ù…Ù†Ø§Ø·Ù‚ Ø§Ù„ÙƒÙˆØ§Ø´Ù Ø§Ù„ÙØ§Ø¦Ù‚Ø© Ø§Ù„ØªÙˆØµÙŠÙ„ (SNSPD).
        """
        cell = gdspy.Cell("Quantum_Detectors")
        
        # Ø£Ø±Ø¨Ø¹Ø© ÙƒÙˆØ§Ø´Ù Ù„Ù…Ù‚Ø§ÙŠÙŠØ³ Bell
        detector_positions = [
            (center[0], center[1] + 15),    # D1
            (center[0], center[1] + 5),     # D2
            (center[0], center[1] - 5),     # D3
            (center[0], center[1] - 15)     # D4
        ]
        
        for i, pos in enumerate(detector_positions):
            # Ù…Ù†Ø·Ù‚Ø© Ø§Ù„ÙƒØ´Ù Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
            detector = gdspy.Rectangle(
                (pos[0] - 3, pos[1] - 2),
                (pos[0] + 3, pos[1] + 2),
                layer=self.layer_detector
            )
            cell.add(detector)
            
            # ÙˆØµÙ„Ø§Øª ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠØ© Ù„Ù„Ù‚Ø±Ø§Ø¡Ø©
            contact_pad = gdspy.Rectangle(
                (pos[0] + 4, pos[1] - 1),
                (pos[0] + 8, pos[1] + 1),
                layer=self.layer_heater
            )
            cell.add(contact_pad)
            
            # ØªØ³Ù…ÙŠØ©
            cell.add(gdspy.Label(f"D{i+1}",
                               (pos[0] - 5, pos[1]),
                               layer=self.layer_detector + 100))
        
        # Ø£Ø¯Ù„Ø© Ù…ÙˆØ¬Ø© Ù„Ù„ÙˆØµÙˆÙ„ Ù„Ù„ÙƒÙˆØ§Ø´Ù
        waveguide_positions = [
            (center[0] - 10, center[1] + 15),
            (center[0] - 10, center[1] + 5),
            (center[0] - 10, center[1] - 5),
            (center[0] - 10, center[1] - 15)
        ]
        
        for i, wg_pos in enumerate(waveguide_positions):
            wg = self.waveguide.create_straight(
                start=(wg_pos[0] - 20, wg_pos[1]),
                end=wg_pos,
                taper_start=0.5,
                taper_end=1.0  # Ø£ÙˆØ³Ø¹ Ø¹Ù†Ø¯ Ø§Ù„ÙƒØ§Ø´Ù
            )
            cell.add(wg)
        
        # ØªØ³Ù…ÙŠØ© Ø¹Ø§Ù…Ø©
        cell.add(gdspy.Label("SNSPD Detectors\n(Superconducting)",
                           (center[0] + 10, center[1]),
                           layer=self.layer_detector + 100))
        
        return cell
    
    def _create_control_circuitry(self) -> gdspy.Cell:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ø¯Ø§Ø±Ø§Øª Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØ©.
        
        ØªØ´Ù…Ù„: Ù…Ø³Ø®Ù†Ø§ØªØŒ Ù…Ø±Ø§Ø­Ù„ØŒ ÙˆÙ…Ù†Ø·Ù‚ ØªØ­ÙƒÙ….
        """
        cell = gdspy.Cell("Control_Circuitry")
        
        # Ù…Ù†Ø·Ù‚Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© (ÙÙŠ Ø£Ø³ÙÙ„ Ø§Ù„Ø±Ù‚Ø§Ù‚Ø©)
        control_center = (250, 50)
        
        # Ù…ÙˆÙ„Ø¯ Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„ØªØ­ÙƒÙ…
        signal_gen = gdspy.Rectangle(
            (control_center[0] - 20, control_center[1] - 10),
            (control_center[0] + 20, control_center[1] + 10),
            layer=self.layer_heater
        )
        cell.add(signal_gen)
        
        cell.add(gdspy.Label("Control\nElectronics",
                           control_center,
                           layer=self.layer_heater + 100))
        
        # Ø®Ø·ÙˆØ· ØªØ­ÙƒÙ… Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø³Ø®Ù†Ø§Øª
        control_lines = []
        heater_positions = [
            (150, 260), (170, 260),  # Ù…Ø³Ø®Ù†Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
            (350, 265), (350, 235),  # Ù…Ø³Ø®Ù†Ø§Øª MZI1
            (350, 215), (350, 185)   # Ù…Ø³Ø®Ù†Ø§Øª MZI2
        ]
        
        for i, heater_pos in enumerate(heater_positions):
            # Ø®Ø· ØªØ­ÙƒÙ…
            line = gdspy.Rectangle(
                (control_center[0] + i*2, control_center[1] + 15),
                (heater_pos[0], heater_pos[1]),
                layer=self.layer_heater
            )
            control_lines.append(line)
            
            # Ù…Ù‚Ø§ÙˆÙ…Ø© Ø§Ù„ØªØ·Ø§Ø¨Ù‚
            resistor = gdspy.Rectangle(
                (heater_pos[0] - 2, heater_pos[1] - 0.5),
                (heater_pos[0] + 2, heater_pos[1] + 0.5),
                layer=self.layer_heater
            )
            control_lines.append(resistor)
        
        # ØªØ¬Ù…ÙŠØ¹ Ø®Ø·ÙˆØ· Ø§Ù„ØªØ­ÙƒÙ…
        if control_lines:
            cell.add(gdspy.boolean(control_lines, None, 'or'))
        
        return cell
    
    def _create_chip_border(self) -> gdspy.PolygonSet:
        """Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø±Ù‚Ø§Ù‚Ø© ÙˆØ¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ù…Ø­Ø§Ø°Ø§Ø©."""
        border_width = 10
        border = gdspy.Rectangle(
            (border_width, border_width),
            (self.chip_size[0] - border_width, self.chip_size[1] - border_width),
            layer=0  # Ø·Ø¨Ù‚Ø© Ø§Ù„Ø­Ø¯ÙˆØ¯
        )
        
        # Ø¹Ù„Ø§Ù…Ø§Øª Ù…Ø­Ø§Ø°Ø§Ø© ÙÙŠ Ø§Ù„Ø²ÙˆØ§ÙŠØ§
        alignment_marks = []
        corners = [
            (border_width + 20, border_width + 20),
            (self.chip_size[0] - border_width - 20, border_width + 20),
            (border_width + 20, self.chip_size[1] - border_width - 20),
            (self.chip_size[0] - border_width - 20, self.chip_size[1] - border_width - 20)
        ]
        
        for corner in corners:
            # Ø¹Ù„Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø´ÙƒÙ„ L
            mark = gdspy.Polygon([
                corner,
                (corner[0] + 5, corner[1]),
                (corner[0] + 5, corner[1] + 5),
                (corner[0], corner[1] + 5)
            ], layer=0)
            alignment_marks.append(mark)
        
        # Ù…Ù†Ø·Ù‚Ø© Ù†ØµÙŠØ© Ù„Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
        info_box = gdspy.Rectangle(
            (self.chip_size[0] - 80, self.chip_size[1] - 30),
            (self.chip_size[0] - 10, self.chip_size[1] - 10),
            layer=0
        )
        
        return gdspy.boolean([border, info_box] + alignment_marks, None, 'or')
    
    def _add_circuit_labels(self) -> List[gdspy.Label]:
        """Ø¥Ø¶Ø§ÙØ© ØªØ³Ù…ÙŠØ§Øª ØªÙˆØ¶ÙŠØ­ÙŠØ© Ù„Ù„Ø¯Ø§Ø±Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©."""
        labels = []
        
        # Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø±Ù‚Ø§Ù‚Ø©
        labels.append(gdspy.Label(
            "QUANTUM SOVEREIGN CHIP\nBell State Generator v1.0",
            (self.chip_size[0]/2, self.chip_size[1] - 20),
            layer=100,
            texttype=1
        ))
        
        # Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹
        perf_text = (
            f"Expected Performance:\n"
            f"â€¢ Fidelity: {self.expected_fidelity:.3f}\n"
            f"â€¢ Pair Rate: {self.pair_generation_rate_hz/1000:.1f} kHz\n"
            f"â€¢ Coincidence Rate: {self.expected_coincidence_rate_hz:.0f} Hz\n"
            f"â€¢ Wavelength: {self.wavelength} Î¼m"
        )
        
        labels.append(gdspy.Label(
            perf_text,
            (self.chip_size[0] - 70, 30),
            layer=100
        ))
        
        # ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        component_labels = [
            ("SPDC Source", (50, 220)),
            ("Polarization\nManagement", (150, 220)),
            ("Entangled\nPhoton Paths", (250, 220)),
            ("MZI Bell State\nEntangler", (350, 220)),
            ("Quantum\nDetectors", (450, 220)),
            ("Control\nElectronics", (250, 70))
        ]
        
        for text, position in component_labels:
            labels.append(gdspy.Label(text, position, layer=100))
        
        return labels
    
    def generate_quantum_performance_report(self) -> Dict:
        """ØªÙˆÙ„ÙŠØ¯ ØªÙ‚Ø±ÙŠØ± Ø¨Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹."""
        
        # Ø­Ø³Ø§Ø¨Ø§Øª Ø£Ø¯Ù‚ Ù„Ù„Ø£Ø¯Ø§Ø¡
        quantum_efficiency = 0.85  # ÙƒÙØ§Ø¡Ø© ÙƒÙ…ÙŠØ©
        collection_efficiency = 0.70  # ÙƒÙØ§Ø¡Ø© Ø¬Ù…Ø¹
        total_efficiency = quantum_efficiency * collection_efficiency * self.detection_efficiency
        
        # Ù…Ø¹Ø¯Ù„Ø§Øª ÙˆØ§Ù‚Ø¹ÙŠØ©
        realistic_pair_rate = self.pair_generation_rate_hz * total_efficiency
        realistic_coincidence_rate = realistic_pair_rate * total_efficiency
        
        # Ø£Ø®Ø·Ø§Ø¡ Ù†Ø¸Ø§Ù…ÙŠØ©
        dark_count_rate = 100  # Hz
        accidental_coincidence_rate = realistic_pair_rate**2 * 1e-9  # ØªÙ‚Ø¯ÙŠØ±ÙŠ
        
        # Ø¥Ø®Ù„Ø§Øµ Ù…ØªÙˆÙ‚Ø¹ Ù…Ø¹ Ø§Ù„Ø£Ø®Ø° ÙÙŠ Ø§Ù„Ø§Ø¹ØªØ¨Ø§Ø± Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
        snr = realistic_coincidence_rate / (accidental_coincidence_rate + dark_count_rate)
        expected_fidelity_with_noise = 0.5 + 0.5 * (snr / (snr + 1))
        
        report = {
            "design_id": "Bell_State_Circuit_v1.0",
            "chip_dimensions_um": self.chip_size,
            "quantum_performance": {
                "expected_fidelity": min(self.expected_fidelity, expected_fidelity_with_noise),
                "pair_generation_rate_hz": realistic_pair_rate,
                "coincidence_rate_hz": realistic_coincidence_rate,
                "accidental_coincidence_rate_hz": accidental_coincidence_rate,
                "signal_to_noise_ratio": snr,
                "total_efficiency": total_efficiency
            },
            "optical_performance": {
                "wavelength_um": self.wavelength,
                "waveguide_loss_db_per_cm": 0.1,
                "component_losses_db": {
                    "spdc_source": 3.0,
                    "polarization_splitter": 1.5,
                    "mzi_network": 2.0,
                    "detector_coupling": 1.0
                },
                "total_insertion_loss_db": 7.5
            },
            "electrical_performance": {
                "heater_resistance_range_ohm": "50-200",
                "power_per_pi_shift_mw": 25.0,
                "thermal_time_constant_ms": 5.0,
                "max_heater_current_ma": 20.0
            },
            "verification_requirements": {
                "minimum_fidelity": 0.95,
                "minimum_coincidence_rate_hz": 1000,
                "maximum_dark_count_rate_hz": 1000,
                "extinction_ratio_db": 20.0
            },
            "estimated_yield": 0.85
        }
        
        return report

# ============================================================================
# Ø³ÙƒØ±ÙŠØ¨Øª Ø§Ù„ØªÙˆÙ„ÙŠØ¯ ÙˆØ§Ù„Ø§Ø®ØªØ¨Ø§Ø±
# ============================================================================

def generate_bell_state_chip():
    """ØªÙˆÙ„ÙŠØ¯ ÙˆØªØµØ¯ÙŠØ± ØªØµÙ…ÙŠÙ… Ø§Ù„Ø±Ù‚Ø§Ù‚Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©."""
    print("ØªÙˆÙ„ÙŠØ¯ Ø±Ù‚Ø§Ù‚Ø© Bell State Ø§Ù„ÙƒÙ…ÙˆÙ…ÙŠØ© Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„Ø©")
    print("=" * 60)
    
    # 1. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ØµÙ…Ù…
    print("\n1. ØªÙ‡ÙŠØ¦Ø© Ù…ØµÙ…Ù… Bell State...")
    bell_chip = BellStateGenerator(
        chip_size=(500, 500),
        wavelength=1.55,
        material="AlGaAs"
    )
    
    # 2. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ø§Ø±Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©
    print("2. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ø§Ø±Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©...")
    complete_circuit = bell_chip.create_complete_circuit()
    
    # 3. ØªÙˆÙ„ÙŠØ¯ ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø£Ø¯Ø§Ø¡
    print("3. ØªÙˆÙ„ÙŠØ¯ ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹...")
    performance_report = bell_chip.generate_quantum_performance_report()
    