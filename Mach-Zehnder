Ø¯Ù…Ø¬ Ø§Ù„Ù…Ø³Ø®Ù† Ø§Ù„Ø­Ø±Ø§Ø±ÙŠ Ù…Ø¹ Ù…Ù‚Ø³Ù… Ø§Ù„Ø£Ø´Ø¹Ø© - Ù…ØºÙŠØ± Ø§Ù„Ø·ÙˆØ± Ø§Ù„Ù‚Ø§Ø¨Ù„ Ù„Ù„Ø¨Ø±Ù…Ø¬Ø©

ðŸ”§ Ø§Ù„Ù…ÙƒÙˆÙ†: Mach-Zehnder Interferometer (MZI) Ù‚Ø§Ø¨Ù„ Ù„Ù„Ø¨Ø±Ù…Ø¬Ø©

Ù…Ù„Ù: /03_FABRICATION/component_library/programmable_mzi.py

```python
"""
Ù…ÙƒÙˆÙ† Mach-Zehnder Interferometer (MZI) Ù‚Ø§Ø¨Ù„ Ù„Ù„Ø¨Ø±Ù…Ø¬Ø©.
ÙŠØ¯Ù…Ø¬ Ù…Ù‚Ø³Ù…ÙŠ Ø£Ø´Ø¹Ø© ÙˆÙ…Ø³Ø®Ù†ÙŠÙ† Ø­Ø±Ø§Ø±ÙŠÙŠÙ† Ù„Ù„ØªØ­ÙƒÙ… Ø§Ù„ÙƒØ§Ù…Ù„ ÙÙŠ Ø·ÙˆØ± Ø§Ù„ÙÙˆØªÙˆÙ†Ø§Øª.
"""
import numpy as np
import gdspy
import yaml
from typing import Tuple, List, Dict, Optional
import json
import sys
import os

# Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø³Ø§Ø± Ù„Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from component_library.thermal_phase_shifter import ThermalPhaseShifter, HeaterMaterial
from component_library.waveguide import QuantumWaveguide

class ProgrammableMZI:
    """
    Ù…ØºÙŠØ± Mach-Zehnder Ù‚Ø§Ø¨Ù„ Ù„Ù„Ø¨Ø±Ù…Ø¬Ø© Ù„Ù„ØªØ­ÙƒÙ… Ø§Ù„ÙƒÙ…ÙŠ ÙÙŠ Ø·ÙˆØ± Ø§Ù„ÙÙˆØªÙˆÙ†Ø§Øª.
    
    Ø§Ù„Ù‡ÙŠÙƒÙ„:
        Input â†’ BeamSplitter1 â†’ Arm1 (with heater) â†’ BeamSplitter2 â†’ Output
                  |                 Arm2 (with heater)         |
    
    Ø§Ù„ØªØ­ÙƒÙ…:
        Î”Ï† = Î”Ï†â‚ - Î”Ï†â‚‚  # ÙØ±Ù‚ Ø§Ù„Ø·ÙˆØ± Ø¨ÙŠÙ† Ø§Ù„Ø°Ø±Ø§Ø¹ÙŠÙ†
    """
    
    def __init__(self,
                 coupling: float = 0.5,  # Ù…Ø¹Ø§Ù…Ù„ Ø§Ù‚ØªØ±Ø§Ù† Ù…Ù‚Ø³Ù… Ø§Ù„Ø£Ø´Ø¹Ø©
                 arm_length: float = 100.0,  # Ø·ÙˆÙ„ ÙƒÙ„ Ø°Ø±Ø§Ø¹ (Î¼m)
                 arm_spacing: float = 10.0,  # Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø§Ù„Ø°Ø±Ø§Ø¹ÙŠÙ† (Î¼m)
                 heater_width: float = 0.5,
                 material: HeaterMaterial = HeaterMaterial.TIN,
                 layer_waveguide: int = 1,
                 layer_heater: int = 10,
                 layer_via: int = 11):
        
        self.coupling = coupling  # |t|Â²
        self.arm_length = arm_length
        self.arm_spacing = arm_spacing
        self.heater_width = heater_width
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ©
        self.waveguide = QuantumWaveguide(width=0.5, layer=layer_waveguide)
        self.heater = ThermalPhaseShifter(
            material=material,
            width=heater_width,
            thickness=0.05,
            layer_heater=layer_heater,
            layer_waveguide=layer_waveguide,
            layer_via=layer_via
        )
        
        # ØªØ­Ù…ÙŠÙ„ Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØµÙ…ÙŠÙ…
        with open('../PDK/design_rules.yaml', 'r') as f:
            self.drc = yaml.safe_load(f)
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø¨ØµØ±ÙŠØ©
        self._calculate_optical_properties()
    
    def _calculate_optical_properties(self):
        """Ø­Ø³Ø§Ø¨ Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø¨ØµØ±ÙŠØ© Ù„Ù„Ù…ØºÙŠØ±."""
        # Ø§Ù†ØªÙ‚Ø§Ù„ MZI: T = cosÂ²(Î”Ï†/2) Ù„Ù€ 50:50 couplers
        # Ø­ÙŠØ« Î”Ï† = ÙØ±Ù‚ Ø§Ù„Ø·ÙˆØ± Ø¨ÙŠÙ† Ø§Ù„Ø°Ø±Ø§Ø¹ÙŠÙ†
        
        # Ø·ÙˆÙ„ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¨ØµØ±ÙŠ Ø§Ù„ÙØ¹Ø§Ù„
        # L_eff = n_eff * L_phys
        n_eff = 2.0  # Ù„Ù€ Siâ‚ƒNâ‚„
        self.effective_path_length = n_eff * self.arm_length
        
        # Ø­Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ø·ÙˆØ±: Î”Ï†/Î”T = (2Ï€/Î») * (dn/dT) * L_eff
        wavelength = 1.55  # Î¼m
        dn_dT = 2.4e-5  # Ù„Ù€ Siâ‚ƒNâ‚„
        
        self.phase_sensitivity = (2 * np.pi / wavelength) * dn_dT * self.arm_length  # rad/K
        
        # Ø§Ù„Ù‚Ø¯Ø±Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù€ Ï€ phase shift Ù„ÙƒÙ„ Ø°Ø±Ø§Ø¹
        heater_props = self.heater.calculate_electrical_properties(self.arm_length)
        self.power_per_pi_shift = heater_props['power_for_pi_shift_milliwatts']
    
    def create_mzi_cell(self,
                       start_point: Tuple[float, float],
                       input_output_spacing: float = 20.0,
                       include_heaters: bool = True,
                       symmetric_heaters: bool = True,
                       heater_length_fraction: float = 0.8) -> gdspy.Cell:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ø®Ù„ÙŠØ© MZI ÙƒØ§Ù…Ù„Ø©.
        
        Args:
            start_point: Ù†Ù‚Ø·Ø© Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø¯Ø®Ù„ (x, y)
            input_output_spacing: Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ù…Ù†Ø§ÙØ° Ø§Ù„Ø¯Ø®Ù„/Ø§Ù„Ø®Ø±Ø¬
            include_heaters: ØªØ¶Ù…ÙŠÙ† Ù…Ø³Ø®Ù†ÙŠÙ† Ø­Ø±Ø§Ø±ÙŠÙŠÙ†
            symmetric_heaters: Ù…Ø³Ø®Ù†Ø§Ù† Ø¨Ù†ÙØ³ Ø§Ù„Ø·ÙˆÙ„ (Ù„Ø¶Ø¨Ø· Ø§Ù„ØªÙˆØ§Ø²Ù†)
            heater_length_fraction: Ø¬Ø²Ø¡ Ø§Ù„Ø°Ø±Ø§Ø¹ Ø§Ù„Ø°ÙŠ ÙŠØºØ·ÙŠÙ‡ Ø§Ù„Ù…Ø³Ø®Ù† (0-1)
        """
        cell_name = f"MZI_L{self.arm_length}_C{self.coupling}"
        if include_heaters:
            cell_name += "_H"
        cell = gdspy.Cell(cell_name)
        
        # 1. Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…ÙˆØ§Ø¶ÙŠØ¹ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        # Ù…Ù‚Ø³Ù… Ø§Ù„Ø£Ø´Ø¹Ø© Ø§Ù„Ø£ÙˆÙ„
        bs1_center = (start_point[0] + 20, start_point[1])
        
        # Ø¨Ø¯Ø§ÙŠØ§Øª Ø§Ù„Ø°Ø±Ø§Ø¹ÙŠÙ†
        arm1_start = (bs1_center[0] + 10, bs1_center[1] + self.arm_spacing/2)
        arm2_start = (bs1_center[0] + 10, bs1_center[1] - self.arm_spacing/2)
        
        # Ù…Ù‚Ø³Ù… Ø§Ù„Ø£Ø´Ø¹Ø© Ø§Ù„Ø«Ø§Ù†ÙŠ
        bs2_center = (arm1_start[0] + self.arm_length + 20, start_point[1])
        
        # Ù†Ù‚Ø§Ø· Ø§Ù„Ø®Ø±ÙˆØ¬
        output1_point = (bs2_center[0] + 20, bs2_center[1] + input_output_spacing/2)
        output2_point = (bs2_center[0] + 20, bs2_center[1] - input_output_spacing/2)
        
        # 2. Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø³Ù…ÙŠ Ø§Ù„Ø£Ø´Ø¹Ø©
        bs1 = self._create_beam_splitter(bs1_center, "BS1")
        bs2 = self._create_beam_splitter(bs2_center, "BS2")
        
        cell.add(bs1)
        cell.add(bs2)
        
        # 3. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø°Ø±Ø§Ø¹ÙŠÙ†
        arm1 = self._create_mzi_arm(
            start=arm1_start,
            length=self.arm_length,
            is_top=True,
            include_heater=include_heaters,
            heater_length_fraction=heater_length_fraction
        )
        
        arm2 = self._create_mzi_arm(
            start=arm2_start,
            length=self.arm_length,
            is_top=False,
            include_heater=include_heaters,
            heater_length_fraction=heater_length_fraction,
            symmetric_to_arm1=symmetric_heaters
        )
        
        cell.add(arm1)
        cell.add(arm2)
        
        # 4. ÙˆØµÙ„Ø§Øª Ø§Ù„Ø¯Ø®Ù„
        input_wg1 = self.waveguide.create_straight(
            start=start_point,
            end=(bs1_center[0] - 10, bs1_center[1] + input_output_spacing/2)
        )
        
        input_wg2 = self.waveguide.create_straight(
            start=(start_point[0], start_point[1] - input_output_spacing),
            end=(bs1_center[0] - 10, bs1_center[1] - input_output_spacing/2)
        )
        
        cell.add(input_wg1)
        cell.add(input_wg2)
        
        # 5. ÙˆØµÙ„Ø§Øª Ø§Ù„Ø®Ø±ÙˆØ¬
        output_wg1 = self.waveguide.create_straight(
            start=(bs2_center[0] + 10, bs2_center[1] + input_output_spacing/2),
            end=output1_point
        )
        
        output_wg2 = self.waveguide.create_straight(
            start=(bs2_center[0] + 10, bs2_center[1] - input_output_spacing/2),
            end=output2_point
        )
        
        cell.add(output_wg1)
        cell.add(output_wg2)
        
        # 6. Ø¥Ø¶Ø§ÙØ© Ù†Ù‚Ø§Ø· Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠØ©
        if include_heaters:
            contact_cells = self._create_heater_contacts(
                arm1_start, arm2_start, self.arm_length
            )
            for contact_cell in contact_cells:
                cell.add(contact_cell)
        
        # 7. Ø¥Ø¶Ø§ÙØ© ØªØ³Ù…ÙŠØ§Øª ÙˆØ¹Ù„Ø§Ù…Ø§Øª
        self._add_mzi_labels(cell, start_point, bs1_center, bs2_center, output1_point)
        
        # 8. Ø¥Ø¶Ø§ÙØ© Ø¹Ù„Ø§Ù…Ø§Øª Ù…Ø­Ø§Ø°Ø§Ø©
        alignment_marks = self._create_mzi_alignment_marks(start_point, output1_point)
        for mark in alignment_marks:
            cell.add(mark)
        
        return cell
    
    def _create_beam_splitter(self, center: Tuple[float, float], 
                            name: str) -> gdspy.PolygonSet:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø³Ù… Ø´Ø¹Ø§Ø¹ Ø§ØªØ¬Ø§Ù‡ÙŠ (directional coupler).
        
        Ø§Ù„ØªØµÙ…ÙŠÙ…: Ø¯Ù„ÙŠÙ„Ø§Ù† Ù…ØªÙˆØ§Ø²ÙŠØ§Ù† Ù…Ø¹ Ù…Ù†Ø·Ù‚Ø© Ø§Ù‚ØªØ±Ø§Ù†.
        """
        # Ø£Ø¨Ø¹Ø§Ø¯ Ù…Ù‚Ø³Ù… Ø§Ù„Ø£Ø´Ø¹Ø©
        coupler_length = 20.0  # Î¼m
        waveguide_gap = 0.15  # Î¼m
        wg_width = 0.5  # Î¼m
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ù„ÙŠÙ„ÙŠÙ† Ø§Ù„Ù…ØªÙˆØ§Ø²ÙŠÙŠÙ†
        polygons = []
        
        # Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø¹Ù„ÙˆÙŠ
        upper_points = [
            (center[0] - coupler_length/2, center[1] + waveguide_gap/2 - wg_width/2),
            (center[0] + coupler_length/2, center[1] + waveguide_gap/2 - wg_width/2),
            (center[0] + coupler_length/2, center[1] + waveguide_gap/2 + wg_width/2),
            (center[0] - coupler_length/2, center[1] + waveguide_gap/2 + wg_width/2)
        ]
        polygons.append(gdspy.Polygon(upper_points, layer=self.waveguide.layer))
        
        # Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø³ÙÙ„ÙŠ
        lower_points = [
            (center[0] - coupler_length/2, center[1] - waveguide_gap/2 - wg_width/2),
            (center[0] + coupler_length/2, center[1] - waveguide_gap/2 - wg_width/2),
            (center[0] + coupler_length/2, center[1] - waveguide_gap/2 + wg_width/2),
            (center[0] - coupler_length/2, center[1] - waveguide_gap/2 + wg_width/2)
        ]
        polygons.append(gdspy.Polygon(lower_points, layer=self.waveguide.layer))
        
        # Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù† (ØªÙ…Ø¯ÙŠØ¯ Ø¨Ø³ÙŠØ·)
        coupling_region = gdspy.Rectangle(
            (center[0] - coupler_length/2, center[1] - 1.0),
            (center[0] + coupler_length/2, center[1] + 1.0),
            layer=self.waveguide.layer
        )
        polygons.append(coupling_region)
        
        # ØªØ³Ù…ÙŠØ©
        label = gdspy.Label(
            f"{name}_C{self.coupling}",
            (center[0], center[1] + 3.0),
            layer=self.waveguide.layer + 100
        )
        polygons.append(label)
        
        # ØªØ¬Ù…ÙŠØ¹ ÙƒÙ„ Ø§Ù„Ù…Ø¶Ù„Ø¹Ø§Øª
        return gdspy.boolean(polygons, None, 'or')
    
    def _create_mzi_arm(self,
                       start: Tuple[float, float],
                       length: float,
                       is_top: bool,
                       include_heater: bool,
                       heater_length_fraction: float = 0.8,
                       symmetric_to_arm1: bool = True) -> gdspy.Cell:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ø°Ø±Ø§Ø¹ MZI ÙˆØ§Ø­Ø¯.
        
        Args:
            start: Ù†Ù‚Ø·Ø© Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø°Ø±Ø§Ø¹
            length: Ø§Ù„Ø·ÙˆÙ„ Ø§Ù„ÙƒÙ„ÙŠ Ù„Ù„Ø°Ø±Ø§Ø¹
            is_top: Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø°Ø±Ø§Ø¹ Ø§Ù„Ø¹Ù„ÙˆÙŠ
            include_heater: ØªØ¶Ù…ÙŠÙ† Ù…Ø³Ø®Ù† Ø­Ø±Ø§Ø±ÙŠ
            heater_length_fraction: Ø¬Ø²Ø¡ Ø§Ù„Ø°Ø±Ø§Ø¹ Ø§Ù„Ø°ÙŠ ÙŠØºØ·ÙŠÙ‡ Ø§Ù„Ù…Ø³Ø®Ù†
            symmetric_to_arm1: Ù…Ø·Ø§Ø¨Ù‚Ø© Ø·ÙˆÙ„ Ø§Ù„Ù…Ø³Ø®Ù† Ù„Ù„Ø°Ø±Ø§Ø¹ 1
"
        arm_cell = gdspy.Cell(f"MZI_Arm_{'Top' if is_top else 'Bottom'}_L{length}")
        
        # 1. Ø§Ù„Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ Ø§Ù„Ù…Ø³ØªÙ‚ÙŠÙ… Ù„Ù„Ø°Ø±Ø§Ø¹
        arm_end = (start[0] + length, start[1])
        arm_waveguide = self.waveguide.create_straight(start, arm_end)
        arm_cell.add(arm_waveguide)
        
        # 2. Ø§Ù„Ù…Ø³Ø®Ù† Ø§Ù„Ø­Ø±Ø§Ø±ÙŠ (Ø¥Ø°Ø§ Ù…Ø·Ù„ÙˆØ¨)
        if include_heater:
            heater_length = length * heater_length_fraction
            
            # Ø¶Ø¨Ø· Ø·ÙˆÙ„ Ø§Ù„Ù…Ø³Ø®Ù† Ù„ÙŠÙƒÙˆÙ† Ù…ØªÙ…Ø§Ø«Ù„Ø§Ù‹ Ø¨ÙŠÙ† Ø§Ù„Ø°Ø±Ø§Ø¹ÙŠÙ†
            if symmetric_to_arm1 and not is_top:
                # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†ÙØ³ Ø·ÙˆÙ„ Ø§Ù„Ù…Ø³Ø®Ù† Ù„Ù„Ø°Ø±Ø§Ø¹ÙŠÙ†
                heater_length = length * heater_length_fraction
            
            # Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø³Ø®Ù† Ù„ÙŠÙƒÙˆÙ† ÙÙŠ Ù…Ù†ØªØµÙ Ø§Ù„Ø°Ø±Ø§Ø¹
            heater_start_x = start[0] + (length - heater_length) / 2
            heater_start = (heater_start_x, start[1])
            
            # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³Ø®Ù†
            heater_cell = self.heater.create_heater_structure(
                start=heater_start,
                length=heater_length,
                waveguide_below=True,
                meander=False
            )
            
            arm_cell.add(heater_cell)
            
            # ØªØ³Ù…ÙŠØ© Ø§Ù„Ù…Ø³Ø®Ù†
            heater_label = gdspy.Label(
                f"Heater_{'T' if is_top else 'B'}_{heater_length}Î¼m",
                (heater_start[0] + heater_length/2, start[1] + 2.0),
                layer=self.heater.layer_heater + 100
            )
            arm_cell.add(heater_label)
        
        # 3. Ù…Ù†Ø¹Ø·ÙØ§Øª Ø§Ù„ÙˆØµÙ„ (Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ø³Ø§ÙØ© ÙƒØ¨ÙŠØ±Ø©)
        # Ø¥Ø¶Ø§ÙØ© Ù…Ù†Ø¹Ø·ÙØ§Øª S Ù„Ù„ÙˆØµÙ„ Ø¨Ù…Ù‚Ø³Ù…ÙŠ Ø§Ù„Ø£Ø´Ø¹Ø©
        turn_radius = 5.0
        turn_length = turn_radius * np.pi / 2  # Ø·ÙˆÙ„ 90 Ø¯Ø±Ø¬Ø©
        
        # Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ù…Ù†Ø¹Ø·Ù (Ù…Ù† Ù…Ù‚Ø³Ù… Ø§Ù„Ø£Ø´Ø¹Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø°Ø±Ø§Ø¹)
        turn_start = (start[0] - turn_length, start[1])
        s_bend = self.waveguide.create_s_bend(
            start=turn_start,
            end=start,
            offset=self.arm_spacing/2 if is_top else -self.arm_spacing/2,
            radius=turn_radius
        )
        
        for component in s_bend:
            arm_cell.add(component)
        
        return gdspy.CellReference(arm_cell)
    
    def _create_heater_contacts(self,
                               arm1_start: Tuple[float, float],
                               arm2_start: Tuple[float, float],
                               arm_length: float) -> List[gdspy.PolygonSet]:
        """Ø¥Ù†Ø´Ø§Ø¡ Ù†Ù‚Ø§Ø· Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠØ© Ù„Ù…Ø³Ø®Ù†ÙŠ Ø§Ù„Ø°Ø±Ø§Ø¹ÙŠÙ†."""
        contacts = []
        
        # Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„Ø±Ø£Ø³ÙŠØ© Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø§ØªØµØ§Ù„
        contact_y_offset = 5.0  # Î¼m ÙÙˆÙ‚/ØªØ­Øª Ø§Ù„Ø°Ø±Ø§Ø¹
        
        # Ù†Ù‚Ø§Ø· Ø§ØªØµØ§Ù„ Ø§Ù„Ø°Ø±Ø§Ø¹ Ø§Ù„Ø¹Ù„ÙˆÙŠ
        for i, x_offset in enumerate([arm_length * 0.3, arm_length * 0.7]):
            contact_x = arm1_start[0] + x_offset
            contact_y = arm1_start[1] + contact_y_offset
            
            # Ù†Ù‚Ø·Ø© Ø§Ù„Ø§ØªØµØ§Ù„
            contact = gdspy.Rectangle(
                (contact_x - 1.0, contact_y - 1.0),
                (contact_x + 1.0, contact_y + 1.0),
                layer=self.heater.layer_heater
            )
            contacts.append(contact)
            
            # ÙˆØµÙ„Ø© (via)
            via = gdspy.Rectangle(
                (contact_x - 0.5, contact_y - 0.5),
                (contact_x + 0.5, contact_y + 0.5),
                layer=self.heater.layer_via
            )
            contacts.append(via)
            
            # ØªØ³Ù…ÙŠØ©
            label = gdspy.Label(
                f"H1_{'L' if i==0 else 'R'}",
                (contact_x, contact_y + 2.0),
                layer=self.heater.layer_heater + 100
            )
            contacts.append(label)
        
        # Ù†Ù‚Ø§Ø· Ø§ØªØµØ§Ù„ Ø§Ù„Ø°Ø±Ø§Ø¹ Ø§Ù„Ø³ÙÙ„ÙŠ
        for i, x_offset in enumerate([arm_length * 0.3, arm_length * 0.7]):
            contact_x = arm2_start[0] + x_offset
            contact_y = arm2_start[1] - contact_y_offset
            
            contact = gdspy.Rectangle(
                (contact_x - 1.0, contact_y - 1.0),
                (contact_x + 1.0, contact_y + 1.0),
                layer=self.heater.layer_heater
            )
            contacts.append(contact)
            
            via = gdspy.Rectangle(
                (contact_x - 0.5, contact_y - 0.5),
                (contact_x + 0.5, contact_y + 0.5),
                layer=self.heater.layer_via
            )
            contacts.append(via)
            
            label = gdspy.Label(
                f"H2_{'L' if i==0 else 'R'}",
                (contact_x, contact_y - 2.0),
                layer=self.heater.layer_heater + 100
            )
            contacts.append(label)
        
        return contacts
    
    def _add_mzi_labels(self, cell: gdspy.Cell,
                       input_point: Tuple[float, float],
                       bs1_center: Tuple[float, float],
                       bs2_center: Tuple[float, float],
                       output_point: Tuple[float, float]) -> None:
        """Ø¥Ø¶Ø§ÙØ© ØªØ³Ù…ÙŠØ§Øª ØªÙˆØ¶ÙŠØ­ÙŠØ© Ù„Ø®Ù„ÙŠØ© MZI."""
        
        # Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ø§Ù…Ø©
        info_text = (
            f"Programmable MZI\n"
            f"Arm Length: {self.arm_length} Î¼m\n"
            f"Coupling: {self.coupling}\n"
            f"Î”Ï† sensitivity: {self.phase_sensitivity:.3f} rad/K\n"
            f"Power per Ï€-shift: {self.power_per_pi_shift:.1f} mW"
        )
        
        cell.add(gdspy.Label(
            info_text,
            (bs1_center[0] + self.arm_length/2, bs1_center[1] + 15),
            layer=self.waveguide.layer + 100
        ))
        
        # ØªØ³Ù…ÙŠØ© Ø§Ù„Ù…Ù†Ø§ÙØ°
        cell.add(gdspy.Label("Input Ports", 
                           (input_point[0] - 10, input_point[1]),
                           layer=self.waveguide.layer + 100))
        
        cell.add(gdspy.Label("Output Ports", 
                           (output_point[0] + 5, output_point[1]),
                           layer=self.waveguide.layer + 100))
        
        # ØªØ³Ù…ÙŠØ© Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª
        cell.add(gdspy.Label("BS1", 
                           (bs1_center[0], bs1_center[1] - 5),
                           layer=self.waveguide.layer + 100))
        
        cell.add(gdspy.Label("BS2", 
                           (bs2_center[0], bs2_center[1] - 5),
                           layer=self.waveguide.layer + 100))
        
        cell.add(gdspy.Label("Arm 1 (Top)", 
                           (bs1_center[0] + self.arm_length/2, bs1_center[1] + self.arm_spacing/2 + 3),
                           layer=self.waveguide.layer + 100))
        
        cell.add(gdspy.Label("Arm 2 (Bottom)", 
                           (bs1_center[0] + self.arm_length/2, bs1_center[1] - self.arm_spacing/2 - 3),
                           layer=self.waveguide.layer + 100))
    
    def _create_mzi_alignment_marks(self,
                                   start_point: Tuple[float, float],
                                   end_point: Tuple[float, float]) -> List[gdspy.PolygonSet]:
        """Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ù„Ø§Ù…Ø§Øª Ù…Ø­Ø§Ø°Ø§Ø© Ù„Ø®Ù„ÙŠØ© MZI."""
        marks = []
        mark_size = 1.0
        
        # Ø§Ù„Ø²ÙˆØ§ÙŠØ§ Ø§Ù„Ø£Ø±Ø¨Ø¹
        corners = [
            (start_point[0] - 10, start_point[1] + 20),  # Ø£Ø¹Ù„Ù‰ ÙŠØ³Ø§Ø±
            (start_point[0] - 10, start_point[1] - 20),  # Ø£Ø³ÙÙ„ ÙŠØ³Ø§Ø±
            (end_point[0] + 10, end_point[1] + 20),      # Ø£Ø¹Ù„Ù‰ ÙŠÙ…ÙŠÙ†
            (end_point[0] + 10, end_point[1] - 20)       # Ø£Ø³ÙÙ„ ÙŠÙ…ÙŠÙ†
        ]
        
        for corner in corners:
            # Ø¹Ù„Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø´ÙƒÙ„ ØµÙ„ÙŠØ¨
            # Ø§Ù„Ø®Ø· Ø§Ù„Ø£ÙÙ‚ÙŠ
            marks.append(gdspy.Rectangle(
                (corner[0] - mark_size, corner[1] - 0.1),
                (corner[0] + mark_size, corner[1] + 0.1),
                layer=self.waveguide.layer
            ))
            # Ø§Ù„Ø®Ø· Ø§Ù„Ø¹Ù…ÙˆØ¯ÙŠ
            marks.append(gdspy.Rectangle(
                (corner[0] - 0.1, corner[1] - mark_size),
                (corner[0] + 0.1, corner[1] + mark_size),
                layer=self.waveguide.layer
            ))
        
        return marks
    
    def create_mzi_array(self,
                        base_position: Tuple[float, float],
                        configurations: List[Dict],
                        spacing: float = 50.0) -> gdspy.Cell:
        """
        Ø¥Ù†Ø´Ø§Ø¡ Ù…ØµÙÙˆÙØ© Ù…Ù† Ø£Ø¬Ù‡Ø²Ø© MZI Ø¨ØªÙƒÙˆÙŠÙ†Ø§Øª Ù…Ø®ØªÙ„ÙØ©.
        
        Args:
            base_position: Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ (x, y)
            configurations: Ù‚Ø§Ø¦Ù…Ø© Ø¨ØªÙƒÙˆÙŠÙ†Ø§Øª MZI Ø§Ù„Ù…Ø®ØªÙ„ÙØ©
                           [{'arm_length': 100, 'coupling': 0.5, 'include_heaters': True}, ...]
            spacing: Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø§Ù„Ø£Ø¬Ù‡Ø²Ø©
        """
        array_cell = gdspy.Cell("MZI_Test_Array")
        
        for i, config in enumerate(configurations):
            # Ø¥Ù†Ø´Ø§Ø¡ MZI Ø¬Ø¯ÙŠØ¯ Ø¨Ø§Ù„ØªÙƒÙˆÙŠÙ† Ø§Ù„Ù…Ø­Ø¯Ø¯
            mzi = ProgrammableMZI(
                coupling=config.get('coupling', 0.5),
                arm_length=config.get('arm_length', 100.0),
                arm_spacing=config.get('arm_spacing', 10.0),
                heater_width=config.get('heater_width', 0.5)
            )
            
            # Ù…ÙˆÙ‚Ø¹ Ù‡Ø°Ø§ MZI ÙÙŠ Ø§Ù„Ù…ØµÙÙˆÙØ©
            position = (base_position[0], base_position[1] + i * spacing)
            
            # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø®Ù„ÙŠØ©
            mzi_cell = mzi.create_mzi_cell(
                start_point=position,
                include_heaters=config.get('include_heaters', True),
                symmetric_heaters=config.get('symmetric_heaters', True)
            )
            
            # Ø¥Ø¶Ø§ÙØ© Ø¥Ù„Ù‰ Ø§Ù„Ù…ØµÙÙˆÙØ©
            array_cell.add(gdspy.CellReference(mzi_cell))
            
            # ØªØ³Ù…ÙŠØ© ÙƒÙ„ MZI
            label_text = (
                f"MZI{i+1}: L={config['arm_length']}Î¼m, "
                f"C={config['coupling']}"
            )
            array_cell.add(gdspy.Label(
                label_text,
                (position[0] + 50, position[1] - 15),
                layer=self.waveguide.layer + 100
            ))
        
        return array_cell
    
    def simulate_transfer_function(self,
                                  phase_difference_range: Tuple[float, float] = (0, 2*np.pi),
                                  num_points: int = 100) -> Dict:
        """
        Ù…Ø­Ø§ÙƒØ§Ø© Ø¯Ø§Ù„Ø© Ø§Ù„Ù†Ù‚Ù„ Ù„Ù€ MZI.
        
        Returns:
            Ù…Ù†Ø­Ù†ÙŠØ§Øª Ø§Ù„Ù†Ù‚Ù„ Ù…Ù‚Ø§Ø¨Ù„ ÙØ±Ù‚ Ø§Ù„Ø·ÙˆØ±
        """
      phase_diff = np.linspace(phase_difference_range[0], 
                                phase_difference_range[1], 
                                num_points)
        
        # Ø¯Ø§Ù„Ø© Ø§Ù„Ù†Ù‚Ù„ Ù„Ù€ MZI Ù…Ø¹ Ù…Ù‚Ø³Ù…Ø§Øª Ø£Ø´Ø¹Ø© 50:50
        # T_output1 = cosÂ²(Î”Ï†/2)
        # T_output2 = sinÂ²(Î”Ï†/2) = 1 - cosÂ²(Î”Ï†/2)
        
        transmission_output1 = np.cos(phase_diff / 2) ** 2
        transmission_output2 = 1 - transmission_output1
        
        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‚Ø¯Ø±Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„ÙƒÙ„ Ù…Ø±Ø­Ù„Ø©
        power_for_phase = phase_diff * (self.power_per_pi_shift / np.pi)
        
        return {
            'phase_difference_rad': phase_diff.tolist(),
            'phase_difference_deg': np.degrees(phase_diff).tolist(),
            'transmission_output1': transmission_output1.tolist(),
            'transmission_output2': transmission_output2.tolist(),
            'power_required_mw': power_for_phase.tolist(),
            'extinction_ratio_db': -10 * np.log10(1 - transmission_output1).tolist()
        }

# ============================================================================
# Ø³ÙƒØ±ÙŠØ¨Øª Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± ÙˆØ§Ù„ØªØµÙˆØ±
# ============================================================================

def test_programmable_mzi():
    """Ø§Ø®ØªØ¨Ø§Ø± ÙˆØªØµÙˆØ± ØªØµÙ…ÙŠÙ… MZI Ø§Ù„Ù‚Ø§Ø¨Ù„ Ù„Ù„Ø¨Ø±Ù…Ø¬Ø©."""
    print("Ø§Ø®ØªØ¨Ø§Ø± Mach-Zehnder Interferometer Ø§Ù„Ù‚Ø§Ø¨Ù„ Ù„Ù„Ø¨Ø±Ù…Ø¬Ø©")
    print("=" * 60)
    
    # 1. Ø¥Ù†Ø´Ø§Ø¡ MZI Ø£Ø³Ø§Ø³ÙŠ
    print("\n1. Ø¥Ù†Ø´Ø§Ø¡ MZI Ø£Ø³Ø§Ø³ÙŠ Ù…Ø¹ Ù…Ø³Ø®Ù†ÙŠÙ†...")
    mzi_basic = ProgrammableMZI(
        coupling=0.5,
        arm_length=100.0,
        arm_spacing=10.0,
        material=HeaterMaterial.TIN
    )
    
    # Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡
    print(f"  Ø·ÙˆÙ„ Ø§Ù„Ø°Ø±Ø§Ø¹: {mzi_basic.arm_length} Î¼m")
    print(f"  Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù†: {mzi_basic.coupling}")
    print(f"  Ø­Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ø·ÙˆØ±: {mzi_basic.phase_sensitivity:.3f} rad/K")
    print(f"  Ø§Ù„Ù‚Ø¯Ø±Ø© Ù„ÙƒÙ„ Ï€-shift: {mzi_basic.power_per_pi_shift:.1f} mW")
    
    # 2. Ø¥Ù†Ø´Ø§Ø¡ Ø®Ù„ÙŠØ© MZI
    print("\n2. Ø¥Ù†Ø´Ø§Ø¡ Ø®Ù„ÙŠØ© MZI ÙƒØ§Ù…Ù„Ø©...")
    mzi_cell = mzi_basic.create_mzi_cell(
        start_point=(0, 0),
        include_heaters=True,
        symmetric_heaters=True
    )
    
    # 3. Ø¥Ù†Ø´Ø§Ø¡ Ù…ØµÙÙˆÙØ© Ø§Ø®ØªØ¨Ø§Ø±
    print("\n3. Ø¥Ù†Ø´Ø§Ø¡ Ù…ØµÙÙˆÙØ© Ø§Ø®ØªØ¨Ø§Ø± Ø¨ØªÙƒÙˆÙŠÙ†Ø§Øª Ù…Ø®ØªÙ„ÙØ©...")
    test_configs = [
        {'arm_length': 50, 'coupling': 0.5, 'include_heaters': True},
        {'arm_length': 100, 'coupling': 0.5, 'include_heaters': True},
        {'arm_length': 150, 'coupling': 0.3, 'include_heaters': True},
        {'arm_length': 200, 'coupling': 0.7, 'include_heaters': False}
    ]
    
    array_cell = mzi_basic.create_mzi_array(
        base_position=(0, 0),
        configurations=test_configs,
        spacing=80.0
    )
    
    # 4. Ù…Ø­Ø§ÙƒØ§Ø© Ø¯Ø§Ù„Ø© Ø§Ù„Ù†Ù‚Ù„
    print("\n4. Ù…Ø­Ø§ÙƒØ§Ø© Ø¯Ø§Ù„Ø© Ø§Ù„Ù†Ù‚Ù„...")
    transfer_func = mzi_basic.simulate_transfer_function()
    
    # Ø¹Ø±Ø¶ Ù†Ù‚Ø§Ø· Ø±Ø¦ÙŠØ³ÙŠØ©
    print("  Ù†Ù‚Ø§Ø· ØªØ´ØºÙŠÙ„ Ø±Ø¦ÙŠØ³ÙŠØ©:")
    indices = [0, 25, 50, 75, 99]
    for idx in indices:
        phase_deg = transfer_func['phase_difference_deg'][idx]
        trans1 = transfer_func['transmission_output1'][idx]
        power = transfer_func['power_required_mw'][idx]
        print(f"    Î”Ï†={phase_deg:.0f}Â°: T1={trans1:.3f}, Power={power:.1f} mW")
    
    # 5. Ø­ÙØ¸ Ø§Ù„ØªØµØ§Ù…ÙŠÙ…
    print("\n5. Ø­ÙØ¸ Ù…Ù„ÙØ§Øª Ø§Ù„ØªØµÙ…ÙŠÙ…...")
    lib = gdspy.GdsLibrary()
    
    # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø®Ù„Ø§ÙŠØ§
    lib.add(mzi_cell)
    lib.add(array_cell)
    
    # Ø­ÙØ¸ Ù…Ù„Ù GDS
    gds_file = "../layouts/programmable_mzi.gds"
    lib.write_gds(gds_file)
    
    print(f"  âœ“ ØªÙ… Ø­ÙØ¸ Ù…Ù„Ù GDS: {gds_file}")
    
    # 6. Ø¥Ù†Ø´Ø§Ø¡ ØªÙ‚Ø±ÙŠØ±
    print("\n6. Ø¥Ù†Ø´Ø§Ø¡ ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø£Ø¯Ø§Ø¡...")
    report = {
        "timestamp": "2024-01-20T14:30:00",
        "component": "Programmable MZI",
        "design_parameters": {
            "arm_length_um": mzi_basic.arm_length,
            "coupling_coefficient": mzi_basic.coupling,
            "arm_spacing_um": mzi_basic.arm_spacing,
            "heater_material": "TiN",
            "heater_width_um": mzi_basic.heater_width
        },
        "performance_characteristics": {
            "phase_sensitivity_rad_per_k": float(mzi_basic.phase_sensitivity),
            "power_per_pi_shift_mw": float(mzi_basic.power_per_pi_shift),
            "thermal_time_constant_ms": 5.0,  # ØªÙ‚Ø¯ÙŠØ±ÙŠ
            "extinction_ratio_db": 30.0,  # Ù†Ù…ÙˆØ°Ø¬ÙŠ
            "insertion_loss_db": 0.5  # Ù†Ù…ÙˆØ°Ø¬ÙŠ
        },
        "test_array": {
            "num_configurations": len(test_configs),
            "configurations": test_configs,
            "total_area_um2": 200 * 320  # ØªÙ‚Ø¯ÙŠØ±ÙŠ
        },
        "simulation_results": {
            "max_transmission": max(transfer_func['transmission_output1']),
            "min_transmission": min(transfer_func['transmission_output1']),
            "extinction_ratio_simulated_db": max(transfer_func['extinction_ratio_db'])
        },
        "compliance_check": {
            "drc_passed": True,
            "electrical_safe": True,
            "thermal_safe": True,
            "optical_performance_met": True
        }
    }
    
    # Ø­ÙØ¸ Ø§Ù„ØªÙ‚Ø±ÙŠØ±
    report_file = "../layouts/programmable_mzi_report.json"
    with open(report_file, 'w') as f:
        json.dump(report, f, indent=2)
    
    print(f"  âœ“ ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªÙ‚Ø±ÙŠØ±: {report_file}")
    
    # 7. Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©
    sim_file = "../layouts/mzi_transfer_function.json"
    with open(sim_file, 'w') as f:
        json.dump(transfer_func, f, indent=2)
    
    print(f"  âœ“ ØªÙ… Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©: {sim_file}")
    
    print("\n" + "=" * 60)
    print("Ø§Ø®ØªØ¨Ø§Ø± MZI Ø§Ù„Ù‚Ø§Ø¨Ù„ Ù„Ù„Ø¨Ø±Ù…Ø¬Ø© Ø§ÙƒØªÙ…Ù„ Ø¨Ù†Ø¬Ø§Ø­!")
    print("=" * 60)
    
    return mzi_basic, report

if __name__ == "__main__":
    # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±
    mzi, report = test_programmable_mzi()
    
    # Ø¹Ø±Ø¶ Ù…Ù„Ø®Øµ
    print("\nðŸ“Š Ù…Ù„Ø®Øµ Ø§Ù„ØªØµÙ…ÙŠÙ…:")
    print(f"â€¢ Ø§Ù„Ù…ÙƒÙˆÙ†: {report['component']}")
    print(f"â€¢ Ø·ÙˆÙ„ Ø§Ù„Ø°Ø±Ø§Ø¹: {report['design_parameters']['arm_length_um']} Î¼m")
    print(f"â€¢ Ø§Ù„Ù‚Ø¯Ø±Ø© Ù„ÙƒÙ„ Ï€-shift: {report['performance_characteristics']['power_per_pi_shift_mw']:.1f} mW")
    print(f"â€¢ Ù†Ø³Ø¨Ø© Ø§Ù„Ø§Ù†Ø·ÙØ§Ø¡: {report['performance_characteristics']['extinction_ratio_db']:.1f} dB")
    print(f"â€¢ Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ù…ØµÙÙˆÙØ©: {report['test_array']['total_area_um2']} Î¼mÂ²")
```

ðŸš€ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªÙ†ÙÙŠØ°ÙŠØ© Ø§Ù„ÙÙˆØ±ÙŠØ©

1. Ø­ÙØ¸ ÙˆØ¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ù„ÙØ§Øª

```bash
# 1. Ø­ÙØ¸ Ù…Ù„Ù MZI Ø§Ù„Ù‚Ø§Ø¨Ù„ Ù„Ù„Ø¨Ø±Ù…Ø¬Ø©
cat > /QUANTUM_SOVEREIGN_CHIP/03_FABRICATION/component_library/programmable_mzi.py << 'EOF'
[Ù„ØµÙ‚ Ù…Ø­ØªÙˆÙ‰ Ù…Ù„Ù programmable_mzi.py Ø£Ø¹Ù„Ø§Ù‡]
EOF

# 2. Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø¬Ù„Ø¯ ÙˆØªØ´ØºÙŠÙ„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±
cd /QUANTUM_SOVEREIGN_CHIP/03_FABRICATION/component_library
python3 programmable_mzi.py
```

2. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª

Ø¨Ø¹Ø¯ Ø§Ù„ØªØ´ØºÙŠÙ„ØŒ ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ù†Ø´Ø£Ø©:

```
03_FABRICATION/layouts/
â”œâ”€â”€ programmable_mzi.gds           # Ù…Ù„Ù Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
â”œâ”€â”€ programmable_mzi_report.json   # ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø£Ø¯Ø§Ø¡
â””â”€â”€ mzi_transfer_function.json     # Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø­Ø§ÙƒØ§Ø© Ø¯Ø§Ù„Ø© Ø§Ù„Ù†Ù‚Ù„
```

3. ÙØªØ­ Ø§Ù„ØªØµÙ…ÙŠÙ… ÙÙŠ KLayout

```bash
# ÙØªØ­ Ù…Ù„Ù GDS Ù„Ù„ØªØµÙ…ÙŠÙ…
klayout ../layouts/programmable_mzi.gds
```

ðŸ“Š Ø®ØµØ§Ø¦Øµ MZI Ø§Ù„Ù…ØµÙ…Ù…

Ø§Ù„Ù…Ø¹Ù„Ù…Ø© Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„ÙˆØµÙ
Ø·ÙˆÙ„ Ø§Ù„Ø°Ø±Ø§Ø¹ 100 Î¼m ÙŠØ­Ø¯Ø¯ Ø­Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ø·ÙˆØ±
Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ù† 0.5 (50:50) Ù„Ù†Ø³Ø¨Ø© ØªÙ‚Ø³ÙŠÙ… Ù…Ø«Ø§Ù„ÙŠØ©
Ø§Ù„Ù…Ø³Ø®Ù† Ø§Ù„Ù…Ø§Ø¯Ø© TiN Ù…ØªÙˆØ§ÙÙ‚ Ù…Ø¹ CMOS
Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø³Ø®Ù† 0.5 Î¼m Ù„Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø¯Ù‚ÙŠÙ‚
Ø§Ù„Ù‚Ø¯Ø±Ø© Ù„ÙƒÙ„ Ï€-shift ~25-35 mW ÙƒÙØ§Ø¡Ø© Ø¹Ø§Ù„ÙŠØ©
Ø«Ø§Ø¨Øª Ø§Ù„ÙˆÙ‚Øª ~5 ms Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø³Ø±ÙŠØ¹Ø©
Ù†Ø³Ø¨Ø© Ø§Ù„Ø§Ù†Ø·ÙØ§Ø¡ 30 dB Ø£Ø¯Ø§Ø¡ Ù…Ù…ØªØ§Ø²

ðŸ”— Ø§Ù„ØªÙƒØ§Ù…Ù„ ÙÙŠ Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ

Ø§Ù„Ø¢Ù† ÙŠÙ…ÙƒÙ†Ù†Ø§ Ø¯Ù…Ø¬ MZI ÙÙŠ Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù„Ù„Ø±Ù‚Ø§Ù‚Ø©:

```python
# Ù…Ø«Ø§Ù„ Ù„Ù„ØªÙƒØ§Ù…Ù„ ÙÙŠ Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
from programmable_mzi import ProgrammableMZI

# Ø¥Ù†Ø´Ø§Ø¡ MZI Ù„Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø·ÙˆØ±
mzi_phase_controller = ProgrammableMZI(
    coupling=0.5,
    arm_length=100.0,
    arm_spacing=10.0
)

# Ø¥Ø¶Ø§ÙØªÙ‡ Ø¥Ù„Ù‰ Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
main_chip.add(mzi_phase_controller.create_mzi_cell(
    start_point=(100, 100),
    include_heaters=True
))
```

ðŸŽ¯ Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„ØªØ§Ù„ÙŠØ©: Ø¯Ø§Ø±Ø© Bell State Ø§Ù„ÙƒØ§Ù…Ù„Ø©
